#!/bin/bash
# MIT License
# Copyright (c) 2026 sunny
# See LICENSE file for full details

# Credits:
# ASCII art used in this script created by DeXteR/MJP and emojicombos.com

set -Eeuo pipefail

#Variables
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
ORIGINAL_USER=${SUDO_USER:-$USER}
ORIGINAL_UID=$(id -u "$ORIGINAL_USER")
USER_HOME=$(getent passwd "$ORIGINAL_USER" | cut -d: -f6)
APP_DIR="$SCRIPT_DIR"
BRANCH="main"               
LOG_FILE="$USER_HOME/cowboy-update/cowboy-update.log"
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true

# Colors (only if output is a TTY)
if [ -t 1 ]; then
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    BOLD="\e[1m"
    DIM="\e[2m"
    RESET="\e[0m"
else
    RED=""; GREEN=""; YELLOW=""; BLUE=""
    MAGENTA=""; CYAN=""; BOLD=""; DIM=""; RESET=""
fi

# Check last update (BEFORE sudo elevation)
if [ -f "$LOG_FILE" ]; then
    LAST_UPDATE=$(tail -1 "$LOG_FILE" | cut -d'|' -f1 | xargs)
    DAYS_SINCE=$(( ( $(date +%s) - $(date -d "$LAST_UPDATE" +%s) ) / 86400 ))
    if [ $DAYS_SINCE -gt 7 ]; then
        echo -e "${YELLOW}тЪая╕П  It's been $DAYS_SINCE days since your last update!${RESET}"
        echo ""
    fi
fi

# Relaunch as root if not already
if [[ $EUID -ne 0 ]]; then
    echo -e "${BOLD}-----Cowboy Update requires sudo privileges to run!-----${RESET}"
    exec sudo "$0" "$@"
fi

# Keep sudo alive in background
keep_sudo_alive() {
    while true; do
        sudo -v
        sleep 50
    done
}
# Start background process to keep sudo alive
keep_sudo_alive &
SUDO_KEEPER_PID=$!
# Kill the sudo keeper when script exits
trap 'kill $SUDO_KEEPER_PID 2>/dev/null; echo "Error on line $LINENO. Exiting."; exit 1' ERR
trap 'kill $SUDO_KEEPER_PID 2>/dev/null' EXIT

print_failure_art() {
cat <<'EOF'
таАтаАтвАтг┤тг╛тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тгп
таАтаАтвйтг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐таШтв┐та╗тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐та┐тг┐таЯтаЛтаА
таАтв┤тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐та┐таЫтг┐тг┐тб┐та┐тг┐тб┐тв╗таЯтг┐тбЯтаАтаИтаАтаЩта╖тбЭта┐тгЭтаЫтаЫтаЙтаЫта╗та┐таЯтв┐тг┐тб┐таДтаАтаАтаАтаАтаАтаА
та╢та┐тв┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тв╗тб┐таБтаАтаАтаЙтаАтаАтаАтаАтаАтаАтб╝таЛтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаА
таАтаАтаЫта┐тг┐тг┐тг┐тб┐тв┐тбПтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаРтаВтаАтаАтаАтаАтаАтаАтаАтаАтаА
таАтаАтаАтаАтвЪтг╜тбЯтаЫтаВтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаА
таАтаАтаАтаАтаИтаНтаАтаАтаАтаАтаАтаАтв╕таАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтгатгжтбАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаА
таАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтв╖тбДтаАтаАтв┤тгДтаШтаГтаАтаАтаАта╗тг┐тбЛтвАтвАтвАтбАтаАтаАтаАтаАтг┐тгдтбАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаА
таАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаИта╗таАтватг╢тг╢тгжтгдтг┤тгЪтг╜тбПтг┐тг┐тг┐тг┐тг╢тгнтгдтгДтаАтаАтг╝тг┐тбЗтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаА
таАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаИтг┐тг┐тг┐тбЬтб┐тг┐тг┐тг┐тв╕тг┐тг┐тг┐тг┐тг┐тг┐тг┐тбЖтаАтг┐тг┐таАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтаА
таАтаАтаАтаАтаАтаАтаАтаАтаАтаАтбАтаАтаАтаАтаАтг╢тгжтгЭтг┐тг┐тбПтг╝тг┐тг┐тг┐таШтг┐тг┐тг┐тг┐тг┐тг┐тг┐тбЗтаАтв╣тбЯтаАтаАтаАтаАтаАтаАтаАтаАтаАтвАтаАтаАтаА
таАтаАтаАтаАтаАтаАтаАтаАтаАтаАтг┐тг┐та┐тбЫтаБтг┐тг┐тг┐таИта╗твЩтв┐тг┐тг┐тбЯтаАтг┐тг┐тг┐тг┐тг┐тг┐тг┐таБтг┐тбМтаГтаАтаАтвАтг┐тгжтгАтаАтвАтг┤тг┐тг╖тгжтбА
таАтаАтаАтаАтаАтаАтаАтаАтаАтаАтвШтг╡тг┐тг╖тг╝тг┐тг┐тбЯтаАтватг┐тг╖таЩтг┐тгзтбАтв┐тг┐тг┐тг┐тг┐тг┐тг┐тб╕тг┐таАтаАтаАтаАтг╛тг┐тг┐тг┐тг╖тгЭтв┐тг┐тг┐тг┐тг┐
таАтаАтвАтгАтгатгдтг┤тг╢та╢твЯтг╝тг┐та┐та┐та┐таЯтаЛтаАтаАтв╣тб┐таГтватг┐тг┐тг┐тг┐тг┐тг┐та┐твЯтглтг┐тгЗтаПтаАтаАтаАтг╝тг┐тг┐тг┐тг┐тг┐тг┐тг╖тготб╗тг┐тг┐
тг╛тг┐тг┐тг┐тг┐тг┐тг┐тгЖтв╕тг┐тг┐тг┐тг┐тг┐тг┐тг╢тг╢тг╢тгдтгШтбАтаАтаИта╗тг┐тг┐та┐та┐та╛та┐твЫтг┐тг┐таГтаАтаАтаАтв░тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐таЯтватг┐тг┐
тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тбОтг┐тг┐тб┐тв┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг╖тг╢тгдтбШтв┐тг╖тг╢тг╢тг╢тг┐тг┐тбПтаАтаАтаАтаАтв╕тг┐тг┐тг┐тг┐тг┐тб┐таЫтаБтгатг╛тг┐тг┐
тг┐тг┐тг┐тг┐тг┐тг┐тб╗таЯтв╕тг┐тг┐тг┐тг┐тг╢тготгнтгЯтгЫтгЫта┐тг┐тг┐таПтаЙтаЩта╖тгЭтг┐тг┐тг┐тг┐таЯтаАтаАтаАтаАтгатг┐тг┐тг┐тг┐таЯтаЙтаАтгатг╛тг┐тг┐тг┐тг┐
таЙтаЙтаЫта╗та┐тг┐тг┐тг╖тбДтаЩта┐та┐тв┐тг┐тг┐тг┐тг┐тг┐таЫтаЛтаАтаАтаАтаАтаАтаАтаАтаИтаЫтаЙтаАтаАтаАтаАтаАтг░тг┐тб┐таЯтаЛтаБтаАтгатг╛тг┐тг┐тг┐тг┐тг┐тг┐
та┐та╖тв╢тажтаАтаИтаЫтг╜тбЗтаАтаАтаАтгАтгАтгИтбЙтаЩтаЫтаАтаАтаАтаАтаАтаАтаАтбАтаАтаАтаАтаАтаАтаАтаАтватг╛таЯтаБтаАтаАтаАтаАтватг┐тг┐тг┐тг┐тг┐тг┐тг┐таЯ
тг┤тг╛тг┐та┐твВтв░тв╖тг┐тбДтаАтаАтаАтаАтаЩта╗та┐тг┐тг╢та╢таДтаАтаАтаАтг┤тг╛тг╖таАтаАтаАтаАтаАтаАтв░тг┐тбЯтаАтаАтаАтаАтбАтаАтв╕тг┐тг┐тг┐тг┐тг┐тб┐таЛтаА
таЯтаЙтгатг╛тбЯтг╛тг╝тг┐тбЗтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтбДтаАтбДтаАтаАтг╜тг┐тгжтбАтаАтаАтаАтвАтг┐тг┐тбЗтаАтаАтаАтвАтг┐тбАтаИтг┐тг┐тг┐тг┐тбЯтаБтаАтаА
тватг╛тг┐тг┐твгтг┐тг┐тбЯтг┐тбДтаАтаАтаАтаАтаАтаАтаАтаАтаАтаГтаАтв╗тбАтаИтаЫта┐тгптбАтаАтаАтвАтг╛тб┐та┐таГтгатбЖтаАтаАтг┐тгзтаАтв╣тг┐тг┐тг┐тг╖тгДтаАтаА
тг┐тг┐тг┐тг┐тг╕тг┐тв╣тг╖тбЩтг┐тгжтаАтаАтаАтаАтаАтаАтаАтаАтаАтаАтг╝тг┐тгжтбАтаАтватбЙтаГтватвЛтгдтаАтватг╛тг┐тбЗтаАтвАтаШтг┐тбДтаИтг┐тг┐тг┐тг┐тг┐тг╖тгд
тг┐тг┐тг┐тг┐тг┐тг┐тбОтв┐тг┐тбМта╗тг╖тбДтаАтаАтаАтаАтаАтаАтаАтв░тв╣тг┐тг┐тг┐тгжтбАта╗тгдтгжтг╛твГтг┤тг┐тг┐тг┐таГтаАтв╕тгЖтаШтаЗтаАтв╣тг┐тг┐тг┐тг┐тг┐тг┐
тг┐тг┐тг┐тг┐тг┐тг┐тг┐тбИтаЫтаЛтаАтаИтаЩтаЖтаАтаАтаАтаАтаАтаАтаБтаАтг┐тг┐тг┐тг┐тг┐тбДтг┐тг┐тг┐тг┐тг┐тг┐тг┐таГтг╝таБтаАтг┐тг┐тг╢тбДтаШтг┐тг┐тг┐тг┐тг┐тг┐
EOF
}

warn() {
    local msg="$1"
    echo -e "${YELLOW}тЪая╕П  WARNING: $msg${RESET}"
    echo "$(date '+%F %T') | WARN | $msg" >> "$LOG_FILE"
}

fatal() {
    local msg="$1"
    echo -e "${RED}тЭМ FATAL: $msg${RESET}"
    echo "$(date '+%F %T') | FATAL | $msg" >> "$LOG_FILE"
    notify_user "Update Failed" "$msg" cowboy-icon
    exit 1
}

notify_user() {
    local title="$1"
    local message="$2"
    local icon="${3:-dialog-information}"
    sudo -u "$ORIGINAL_USER" \
        DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" \
        notify-send -a "Cowboy Update" -i "$icon" "$title" "$message"
}

self_update() {
    # Make sure git exists
    if ! command -v git &>/dev/null; then
        echo "git is required for self-update, skipping..."
        return
    fi
    
    # SCRIPT_DIR is already defined at the top of the script
    if [ ! -d "$SCRIPT_DIR/.git" ]; then
        echo "Error: $SCRIPT_DIR is not a git repository!"
        return
    fi

    cd "$SCRIPT_DIR" || return

    # Fetch latest changes
    git fetch origin "$BRANCH" --quiet

    # Detect if HEAD is detached
    DETACHED=$(git symbolic-ref --quiet --short HEAD || echo "DETACHED")

    if [ "$DETACHED" = "DETACHED" ]; then
        echo -e "\e[33mDetached HEAD detected. Resetting to $BRANCH\e[0m"
        git checkout -B "$BRANCH" "origin/$BRANCH"
    else
        # Make sure local branch exists and tracks remote
        git checkout "$BRANCH" >/dev/null 2>&1 || git checkout -b "$BRANCH" "origin/$BRANCH"
    fi

    LOCAL_HASH=$(git rev-parse HEAD)
    REMOTE_HASH=$(git rev-parse origin/"$BRANCH")

    echo "Local:  $LOCAL_HASH"
    echo "Remote: $REMOTE_HASH"

    if [ "$LOCAL_HASH" != "$REMOTE_HASH" ]; then
        echo -e "\e[33mA new update for Cowboy Update is available!\e[0m"
        read -rp "Do you want to update now? (y/N): " choice
        case "$choice" in
            y|Y)
                echo -e "\e[32mUpdating Cowboy Update...\e[0m"

                # Stash local changes if any
                STASHED=false
                if ! git diff-index --quiet HEAD --; then
                    git stash push -q -u -m "cowboy-update-autostash-$(date +%F_%H%M%S)"
                    STASHED=true
                fi

                # Force reset to remote branch
                git reset --hard "origin/$BRANCH"
                git clean -fd

                # Reapply stash if needed
                if [ "$STASHED" = true ]; then
                    git stash pop -q 2>/dev/null || echo "Could not reapply stashed changes"
                fi

                echo -e "\e[32mUpdate pulled successfully! New commit: $(git rev-parse HEAD)\e[0m"

                echo -e "\e[32mUpdate complete! Relaunching...\e[0m"
                # Get the full path to the script
                SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
                exec "$SCRIPT_PATH" "$@"
                ;;
            *)
                echo -e "${YELLOW}Update skipped.${RESET}"
                ;;
        esac
    else
        echo -e "${GREEN}Cowboy-update is already on the latest version.${RESET}"
    fi
}

backup_pacman_db() {
    local backup_dir="$USER_HOME/cowboy-update/pacman-backup"
    mkdir -p "$backup_dir"

    # Remove backups older than 30 days
    find "$backup_dir" -type f -name "pacman-db-*.tar.gz" -mtime +30 -exec rm -v {} \; 2>/dev/null

    local timestamp
    timestamp=$(date +%F_%H%M%S)
    local backup_file="$backup_dir/pacman-db-$timestamp.tar.gz"

    echo -e "${YELLOW}тП│ Backing up pacman database...${RESET}"

    # Backup local and sync databases
    if sudo tar -czf "$backup_file" /var/lib/pacman/local /var/lib/pacman/sync; then
        echo -e "${GREEN}тЬУ Pacman database backup saved to $backup_file${RESET}"
        echo -e "${DIM}Backups older than 30 days have been cleaned automatically.${RESET}"
        echo
        echo -e "${CYAN}ЁЯТб Tip: To inspect or restore a backup if needed:${RESET}"
        echo -e "${CYAN}   Inspect package info: tar -xzf $backup_file -C /tmp && pacman -Qkk /tmp/local/*${RESET}"
        echo -e "${CYAN}   Restore pacman DB: sudo tar -xzf $backup_file -C /${RESET}"
    else
        warn "Pacman database backup failed"
    fi
}

warn_large_update() {
    # Get list of packages that would be upgraded
    UPDATE_LIST=$(checkupdates 2>/dev/null || true)

    # Only count if we got results
    if [ -n "$UPDATE_LIST" ]; then
        NUM_UPDATES=$(echo "$UPDATE_LIST" | wc -l)

        # Threshold for "large update"
        LARGE_UPDATE_THRESHOLD=20

        if [ "$NUM_UPDATES" -gt $LARGE_UPDATE_THRESHOLD ]; then
            echo -e "${YELLOW}тЪая╕П  There are $NUM_UPDATES packages to update.${RESET}"
            echo -e "${YELLOW}This is a large update and may take a while.${RESET}"

            # Backup pacman DB only if last backup was >30 days ago
            local backup_dir="$USER_HOME/cowboy-update/pacman-backup"
            local last_backup_file="$backup_dir/.last_backup"

            local need_backup=true
            if [ -f "$last_backup_file" ]; then
                local last_backup_ts
                last_backup_ts=$(cat "$last_backup_file")
                local days_since=$(( ( $(date +%s) - last_backup_ts ) / 86400 ))
                if [ "$days_since" -le 30 ]; then
                    need_backup=false
                fi
            fi

            if [ "$need_backup" = true ]; then
                read -p "Do you want to create a pacman database backup before proceeding? (y/N): " backup_choice
                if [[ "$backup_choice" =~ ^[Yy]$ ]]; then
                    backup_pacman_db
                    # Record backup timestamp
                    mkdir -p "$backup_dir"
                    date +%s > "$last_backup_file"
                else
                    echo -e "${YELLOW}Skipping pacman database backup.${RESET}"
                fi
            else
                echo -e "${CYAN}Pacman DB was backed up recently, skipping backup prompt.${RESET}"
            fi

            read -p "Do you want to proceed with the update? (y/N): " proceed
            if [[ ! "$proceed" =~ ^[Yy]$ ]]; then
                echo -e "${GREEN}Update canceled.${RESET}"
                exit 0
            fi
        fi
    fi
}

check_disk_space() {
    AVAILABLE_SPACE=$(df / | tail -1 | awk '{print $4}')
    AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
    
    if [ $AVAILABLE_GB -lt 5 ]; then
        echo ""
        echo -e "${RED}тЪая╕П  WARNING: Only ${AVAILABLE_GB}GB free space available!${RESET}"
        echo "Recommended: At least 5GB free for safe updates"
        read -p "Continue anyway? (y/N): " continue_update
        if [[ ! "$continue_update" =~ ^[Yy]$ ]]; then
            echo "Update cancelled. Free up some space first."
            exit 0
        fi
    fi
}
reboot_prompt() {
    if [[ "$KERNEL_UPDATED" = true || "$GPU_UPDATED" = true ]]; then
        read -p "Reboot recommended. Reboot now? (y/N): " choice
        [[ "$choice" =~ ^[Yy]$ ]] && reboot
    fi
}

create_rollback_snapshot() {
    KEEP_SNAPSHOTS=2
    SNAP_DIR="/var/lib/cowboy-update/.snapshots"
    sudo mkdir -p "$SNAP_DIR"

    # Detect root mount
    ROOT_FS=$(findmnt -n -o FSTYPE /)
    if [ "$ROOT_FS" != "btrfs" ]; then
        echo "$(date '+%F %T') | SNAPSHOT | SKIPPED | Root FS is not Btrfs" >> "$LOG_FILE"
        return
    fi

    # Determine absolute path of root subvolume
    ROOT_SUBVOL_PATH=$(btrfs subvolume list / -p | awk '$5=="/"{print $9}' | head -n1)
    [ -z "$ROOT_SUBVOL_PATH" ] && ROOT_SUBVOL_PATH="/"
    [ ! -d "/$ROOT_SUBVOL_PATH" ] && ROOT_SUBVOL_PATH="/"
    ROOT_SUBVOL_PATH="/$ROOT_SUBVOL_PATH"

    # Detect last Cowboy rollback snapshot
    LAST_ROLLBACK=$(find "$SNAP_DIR" -maxdepth 1 -type d -name "cowboy-rollback-*" | sort -r | head -1)
    LAST_SNAP_TS=0
    [ -n "$LAST_ROLLBACK" ] && LAST_SNAP_TS=$(stat -c %Y "$LAST_ROLLBACK" 2>/dev/null || echo 0)
    DAYS_SINCE=$(( ( $(date +%s) - LAST_SNAP_TS ) / 86400 ))

    # Silent skip if recent snapshot exists (<14 days)
    [ "$LAST_SNAP_TS" -ne 0 ] && [ "$DAYS_SINCE" -lt 14 ] && return

    # Ask user to create snapshot
    read -rp "Create a rollback snapshot now? (y/N): " choice
    [[ ! "$choice" =~ ^[Yy]$ ]] && { echo "Skipping rollback snapshot."; return; }

    # Timeshift snapshot (if installed)
    if command -v timeshift &>/dev/null; then
        sudo timeshift --create --comments "Cowboy rollback $(date '+%F %H:%M:%S')" --tags D
        echo "$(date '+%F %T') | SNAPSHOT | TIMESYNC | Success" >> "$LOG_FILE"
    fi

    # Btrfs snapshot
    SNAP_NAME="cowboy-rollback-$(date '+%F_%H%M%S')"
    SNAP_PATH="$SNAP_DIR/$SNAP_NAME"
    if sudo btrfs subvolume snapshot -r "$ROOT_SUBVOL_PATH" "$SNAP_PATH"; then
        echo "$(date '+%F %T') | SNAPSHOT | BTRFS | Created at $SNAP_PATH" >> "$LOG_FILE"
    else
        echo "$(date '+%F %T') | SNAPSHOT | BTRFS | FAILED" >> "$LOG_FILE"
        return 1
    fi

    # Keep only last N snapshots
    SNAP_COUNT=$(ls -1t "$SNAP_DIR" 2>/dev/null | wc -l)
    while [ "$SNAP_COUNT" -gt "$KEEP_SNAPSHOTS" ]; do
        OLDEST=$(ls -1t "$SNAP_DIR" | tail -1)
        sudo btrfs subvolume delete "$SNAP_DIR/$OLDEST"
        echo "$(date '+%F %T') | SNAPSHOT | BTRFS | Deleted $OLDEST" >> "$LOG_FILE"
        SNAP_COUNT=$((SNAP_COUNT - 1))
    done

    echo
    echo -e "${CYAN}тЬЕ Btrfs snapshot created at $SNAP_PATH${RESET}"
    echo -e "${CYAN}ЁЯУМ Note: In case of issues, select this snapshot from your bootloader (Grub/OS-prober) to rollback.${RESET}"
    echo
}


log_summary() {
    echo "$(date '+%F %T') | Time: ${MINUTES}m ${SECONDS}s | Packages: $PACKAGES_UPDATED | AUR: $AUR_UPDATED | Flatpaks: $FLATPAKS_UPDATED | Orphans: $ORPHANS_REMOVED | Cache: $CACHE_CLEANED | Kernel: $([ "$KERNEL_UPDATED" = true ] && echo YES || echo NO) | GPU: $([ "$GPU_UPDATED" = true ] && echo YES || echo NO)" >> "$LOG_FILE"
}

report_pacnew_files() {
    PACNEW_COUNT=$(find /etc -name "*.pacnew" 2>/dev/null | wc -l)
    PACSAVE_COUNT=$(find /etc -name "*.pacsave" 2>/dev/null | wc -l)

    if [ "$PACNEW_COUNT" -eq 0 ] && [ "$PACSAVE_COUNT" -eq 0 ]; then
        return
    fi

    echo
    echo -e "${YELLOW}тЪая╕П  Config files need review${RESET}"
    echo "  .pacnew files:  $PACNEW_COUNT"
    echo "  .pacsave files: $PACSAVE_COUNT"
    echo
    echo "Nothing was overwritten."
    echo "Review later with:"
    echo "  sudo pacdiff"
    echo

    echo "$(date '+%F %T') | PACNEW | $PACNEW_COUNT pacnew | $PACSAVE_COUNT pacsave" >> "$LOG_FILE"
}

# Verify pacman database isn't corrupted
check_database_health() {
    echo "Checking pacman database integrity..."

    # pacman -Qk returns non-zero when missing files exist (normal)
    DB_OUTPUT=$(pacman -Qk 2>/dev/null || true)

    # Extract ONLY package summary lines with missing files
    BAD_PKGS=$(echo "$DB_OUTPUT" \
        | grep -E "missing file[s]?\)$" \
        | grep -v ": 0 missing" \
        || true)

    if [ -z "$BAD_PKGS" ]; then
        echo -e "${GREEN}тЬУ Database is healthy${RESET}"
        echo "$(date '+%F %T') | DB CHECK | OK | 0 packages affected" >> "$LOG_FILE"
        return 0
    fi

    PKG_COUNT=$(echo "$BAD_PKGS" | wc -l)

    echo -e "${YELLOW}тЪая╕П  $PKG_COUNT package(s) with missing files detected${RESET}"
    echo
    echo "$BAD_PKGS"
    echo

    if [ "$PKG_COUNT" -le 3 ]; then
        echo -e "${DIM}This is very common on Arch and usually harmless.${RESET}"
        echo -e "${DIM}Optional fix:${RESET}"
        echo -e "${DIM}  sudo pacman -Syu --overwrite '*'${RESET}"
        SEVERITY="LOW"
        warn "some missing packages, continuing update."
    else
        echo -e "${RED}тЪая╕П  Multiple packages affected тАФ investigate.${RESET}"
        SEVERITY="HIGH"
    fi

    echo "$(date '+%F %T') | DB CHECK | $SEVERITY | $PKG_COUNT packages affected" >> "$LOG_FILE"
}

echo -e "${CYAN}
тХФтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХЧ
тХС                                  тХС
тХС                                  тХС
тХС       COWBOY-UPDATE SCRIPT       тХС
тХС                                  тХС
тХС              sunny               тХС
тХЪтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХРтХЭ${RESET}"
cat <<'EOF'
  (                                 _
   )                               /=>
  (  +____________________/\/\___ / /|
   .''._____________'._____      / /|/\
  : () :              :\ ----\|    \ )
   '..'______________.'0|----|      \
                    0_0/____/        \
                        |----    /----\
                       || -\\ --|      \
                       ||   || ||\      \
                        \\____// '|      \
                                .'/       |
                               .:/        |
                               :/_________|
EOF
read -p "Press Enter to begin..."

self_update
create_rollback_snapshot

# Track stats
PACKAGES_UPDATED=0
AUR_UPDATED=0
FLATPAKS_UPDATED=0
ORPHANS_REMOVED=0
CACHE_CLEANED="0 MB"
START_TIME=$(date +%s)

# Check Arch news
echo
echo -e "${BOLD}Checking recent Arch news...${RESET}"
curl -s https://archlinux.org/feeds/news/ | grep -oP '(?<=<title>).*?(?=</title>)' | head -n 5 | tail -n 4
echo ""
read -p "Press Enter to continue with updates..."
echo

# Track if kernel or GPU drivers were updated during this run
KERNEL_UPDATED=false
GPU_UPDATED=false

warn_large_update
check_disk_space
check_database_health

# Update official repos
echo
echo "======================================="
echo -e "${GREEN}Updating Official Repository...${RESET}"
echo "======================================="
# Capture pacman output to check if kernel was updated
PACMAN_LOG=$(mktemp)

# Run pacman (disable exit-on-error for this command)
set +e
script -q -c "pacman -Syu" "$PACMAN_LOG"
PACMAN_EXIT=$?
set -e

PACMAN_OUTPUT=$(cat "$PACMAN_LOG")
rm "$PACMAN_LOG"

# Count packages updated (handle case where grep finds nothing)
if echo "$PACMAN_OUTPUT" | grep -q "upgrading"; then
    PACKAGES_UPDATED=$(echo "$PACMAN_OUTPUT" | grep -c "upgrading")
else
    PACKAGES_UPDATED=0
fi

# Check for any kernel package update (CachyOS or standard Arch)
if echo "$PACMAN_OUTPUT" | grep -qE 'upgrading linux(-|$)'; then
    KERNEL_UPDATED=true
fi

# Check for GPU driver updates (NVIDIA, AMD, Intel)
if echo "$PACMAN_OUTPUT" | grep -qE 'upgrading (nvidia|mesa|xf86-video|vulkan-|amdgpu)'; then
    GPU_UPDATED=true
fi

if [ $PACMAN_EXIT -ne 0 ] || echo "$PACMAN_OUTPUT" | tail -5 | grep -qi "error\|failed"; then
        echo -e "${YELLOW}pacman failed!${RESET}"
        print_failure_art
        notify_user "Update Failed" "pacman failed" cowboy-icon
        fatal "pacman failed"
fi

echo
echo "======================================="
echo -e "${GREEN}Updating AUR Packages...${RESET}"
echo "======================================="
set +e
AUR_OUTPUT=$(sudo -u "$ORIGINAL_USER" paru -Sua 2>&1 | tee /dev/tty)
PARU_EXIT=$?
set -e

# Count AUR packages updated
if echo "$AUR_OUTPUT" | grep -q "upgrading"; then
    AUR_UPDATED=$(echo "$AUR_OUTPUT" | grep -c "upgrading")
else
    AUR_UPDATED=0
fi

if [ $PARU_EXIT -ne 0 ]; then
    echo -e "${YELLOW}paru failed!${RESET}"
    print_failure_art
    notify_user "Update Failed" "paru failed" cowboy-icon
    warn "paru failed, continuing update"
fi

echo
echo "======================================="
echo -e "${GREEN}Updating Flatpaks...${RESET}"
echo "======================================="

# Update system-level flatpaks (as root)
echo "Updating system flatpaks..."
set +e
FLATPAK_SYSTEM_OUTPUT=$(flatpak update --system -y 2>&1 | tee /dev/tty)
FLATPAK_SYSTEM_EXIT=$?
set -e
echo

# Update user-level flatpaks (as original user)
echo "Updating user flatpaks..."
set +e
FLATPAK_USER_OUTPUT=$(sudo -u "$ORIGINAL_USER" DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" flatpak update --user -y 2>&1 | tee /dev/tty)
FLATPAK_USER_EXIT=$?
set -e

# Count updates from both outputs
SYSTEM_COUNT=0
USER_COUNT=0
if echo "$FLATPAK_SYSTEM_OUTPUT" | grep -q "Installing\|Updating"; then
    SYSTEM_COUNT=$(echo "$FLATPAK_SYSTEM_OUTPUT" | grep -c "Installing\|Updating")
fi
if echo "$FLATPAK_USER_OUTPUT" | grep -q "Installing\|Updating"; then
    USER_COUNT=$(echo "$FLATPAK_USER_OUTPUT" | grep -c "Installing\|Updating")
fi
FLATPAKS_UPDATED=$((SYSTEM_COUNT + USER_COUNT))

# Check if either failed
if [ $FLATPAK_SYSTEM_EXIT -ne 0 ] || [ $FLATPAK_USER_EXIT -ne 0 ]; then
    echo -e "${YELLOW}flatpak update failed!${RESET}"
    print_failure_art
    notify_user "Update Failed" "flatpak failed" cowboy-icon
    warn "flatpak failed, continuing update"
fi

echo
echo "======================================="
echo -e "${YELLOW}Cleaning...${RESET}"
echo "======================================="
# Show disk space saved - var before
BEFORE=$(df / | tail -1 | awk '{print $4}')

# Check for orphaned packages
echo
echo "Checking for orphaned packages..."
echo
ORPHANS=$(pacman -Qtdq 2>/dev/null || true)
if [ -n "$ORPHANS" ]; then
    ORPHANS_REMOVED=$(echo "$ORPHANS" | wc -l)
    ORPHANS_REMOVED=${ORPHANS_REMOVED//[^0-9]/}  # Keep only digits
    echo "Found orphaned packages:"
    echo "$ORPHANS"
    read -p "Remove them? (y/n): " choice
    if [[ $choice == "y" || $choice == "Y" ]]; then
        set +e
        pacman -Rns $ORPHANS --noconfirm
        set -e
    else
        ORPHANS_REMOVED=0
    fi
else
    echo "No orphaned packages found."
    echo
    ORPHANS_REMOVED=0
fi

# Clean package cache (keep last 2 versions)
echo "Cleaning package cache..."
echo
if command -v paccache &> /dev/null; then

    CACHE_BEFORE=$(du -sm /var/cache/pacman/pkg/ | awk '{print $1}')
    
    paccache -rk2 > /dev/null 2>&1
    paccache -ruk0 > /dev/null 2>&1
    
    CACHE_AFTER=$(du -sm /var/cache/pacman/pkg/ | awk '{print $1}')
    CACHE_CLEANED="$((CACHE_BEFORE - CACHE_AFTER)) MB"
else
    echo "paccache not found (install pacman-contrib)"
    CACHE_CLEANED="0 MB"
fi

# Clean Flatpak cache
if command -v flatpak &> /dev/null; then
    echo "Cleaning Flatpak cache..."
    echo
    # Clean system flatpaks
    flatpak uninstall --system --unused -y > /dev/null 2>&1
    # Clean user flatpaks
    sudo -u "$ORIGINAL_USER" DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" flatpak uninstall --user --unused -y > /dev/null 2>&1
fi

report_pacnew_files

# List services using old libraries
if command -v needrestart &> /dev/null; then
    echo "Checking for services needing restart..."
    needrestart -l
fi

# ... do updates and cleaning results...
AFTER=$(df / | tail -1 | awk '{print $4}')
SAVED=$((AFTER - BEFORE))  # in KB (usually df -k, but yours seems blocks?)
SAVED_MB=$((SAVED / 1024))

if [ "$SAVED_MB" -ge 1024 ]; then
    # Convert to GB with one decimal
    SAVED_GB=$(awk "BEGIN {printf \"%.1f\", $SAVED_MB/1024}")
    echo "Freed up: ${SAVED_GB} GB"
else
    echo "Freed up: ${SAVED_MB} MB"
fi


# Check if reboot needed
if [ "$KERNEL_UPDATED" = true ] || [ "$GPU_UPDATED" = true ]; then
    echo
    echo "тЪая╕П  ========================================== тЪая╕П"
    echo "тЪая╕П           REBOOT RECOMMENDED              тЪая╕П"
    echo "тЪая╕П  ========================================== тЪая╕П"
    
    if [ "$KERNEL_UPDATED" = true ] && [ "$GPU_UPDATED" = true ]; then
        echo "   Kernel AND GPU drivers were updated!"
        notify_user "Reboot Recommended" "Kernel and GPU drivers updated" dialog-warning
    elif [ "$KERNEL_UPDATED" = true ]; then
        echo "   Kernel was updated!"
        notify_user "Reboot Recommended" "Kernel was updated" dialog-warning
    else
        echo "   GPU drivers were updated!"
        notify_user "Reboot Recommended" "GPU drivers updated" dialog-warning
    fi
    
    echo "тЪая╕П  ========================================== тЪая╕П"
    echo
fi

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))
MINUTES=$((DURATION / 60))
SECONDS=$((DURATION % 60))

log_summary
reboot_prompt

echo "+------------------------------------+"
echo -e "|${GREEN} SUCCESS! YOU CARRIED THAT WEIGHT!${RESET}  |"
echo "+------------------------------------+"
    echo -e "${BOLD}тг┐тг┐тг┐тг┐тг┐тб┐таЫтаЛтаЩтаЙтаЛтаЫта┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐та┐та┐та┐та┐тв┐тг┐тг┐тг┐тг┐
тг┐тг┐тг┐тг┐тгетг┤тг╢тг┐тг┐тг┐тг┐тг╖тгжтбИтаЩтг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тб┐таЫтгБтгдтгдтг╢тг╢тгдтгдтгИтг╗тг┐тг┐
тг┐тг┐тг┐тг┐тб┐та┐таЫтаЫта╗та┐тг┐тг┐тг┐тг┐тгзтгИтг┐тг┐тг┐тг┐тг┐тг┐таПтгбтг╛тг┐тг┐тг┐тг┐тб┐та┐тв┐тг┐тг┐тг┐тг┐
тг┐тг┐тг┐тбПтаАтбАтаВтаДтбБтаРтвШтг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тбЯтаЙтаАтбАтаДтаатаАтаЩтг┐тг┐
тг┐тб┐тв┐тг╖тгжтгдтгетг┤тгдтг╡тг╛тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг╖тгдтгБтгАтгВтгБтгмтг┤тб┐тв┐
тг┐таАтгжтгЙтаЫта┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐та┐таЛтгбтг┤таИ
тгзтаАтг┐тг┐тв░тгжтгмтгЙтаЫта┐тв┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐та┐таЯтаЛтгЙтгдтг╢твРтг┐тг┐таА
тг┐таАтг┐тб┐тв╕тг┐тг┐тг┐тг┐таАтгдтгдтгНтгЙтгЩтаЩтаЫтаЫтаЫтаЫтаЫтаЙтгЙтгЙтгетгдтгдтаАтг┐тг┐тг┐тг┐тв╕тг┐тбЯтва
тг┐тбДтв╗тбЗтв╕тг┐тг┐тг┐тг┐таАтг┐тг┐тг┐тг┐тг┐таАтг┐тг┐тг┐тг┐тб┐таАтг┐тг┐тг┐тг┐тбЗтаатг┐тг┐тг┐тб┐тв╕тг┐таЗтг╝
тг┐тг╖тбИтаЗтв╕тг┐тг┐тг┐тг┐таАтг┐тг┐тг┐тг┐тг┐таАтг┐тг┐тг┐тг┐тбЗтвИтг┐тг┐тг┐тг┐тбЗтв╕тг┐тг┐тг┐тбЗтв╕тбЯтватг┐
тг┐тг┐тг╖тбАтв╕тг┐тг┐тг┐тг┐таАтг┐тг┐тг┐тг┐тг┐таАтг┐тг┐тг┐тг┐тбЗтв╕тг┐тг┐тг┐тг┐тбЗтв╕тг┐тг┐тг┐тбЗтаШтватг┐тг┐
тг┐тг┐тг┐тг╖тгМта╗тг┐тг┐тг┐таАтг┐тг┐тг┐тг┐тг┐таАтг┐тг┐тг┐тг┐тбЗтв╕тг┐тг┐тг┐тг┐тбЗтв╕тг┐тг┐тб┐таГтг░тг┐тг┐тг┐
тг┐тг┐тг┐тг┐тг┐тгзтбИта╗тбПтаатг┐тг┐тг┐тг┐тбПтаРтг┐тг┐тг┐тг┐тбЗтв╕тг┐тг┐тг┐тг┐тбЗтв╕тб┐таЫтгбтг╛тг┐тг┐тг┐тг┐
тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг╖тгДтбРта╗тв┐тг┐тг┐тбЗтвитг┐тг┐тг┐тг┐тбЗтв╕тг┐тг┐тг┐тб┐таГтгИтгдтг╛тг┐тг┐тг┐тг┐тг┐тг┐
тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг╖тгжтгмтгЙтгГтаШтаЫтаЫтаЫтаЫтаГтаШтгЫтгЙтгетг┤тг╛тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐тг┐${RESET}"

# --- Snapshot Summary ---
echo "+------------------------------------+"
echo -e "|${GREEN}          BACKUP SUMMARY${RESET}            |"
echo "+------------------------------------+"

if [ -d "$SNAP_DIR" ]; then
    # Get most recent snapshot
    LATEST_SNAP=$(ls -1t "$SNAP_DIR" 2>/dev/null | head -1)
    if [ -z "$LATEST_SNAP" ]; then
        echo "No Cowboy rollback snapshots found."
        SNAPSHOT_STATUS="NO"
    else
        SNAP_PATH="$SNAP_DIR/$LATEST_SNAP"
        SNAP_TS=$(stat -c %Y "$SNAP_PATH" 2>/dev/null || echo 0)
        AGE_DAYS=$(( ( $(date +%s) - SNAP_TS ) / 86400 ))
        echo "$LATEST_SNAP (age: $AGE_DAYS day(s)) at $SNAP_PATH"
        SNAPSHOT_STATUS="YES"
    fi
else
    echo "Snapshot directory $SNAP_DIR not found."
    SNAPSHOT_STATUS="NO"
fi

echo -e "${MAGENTA}^^IN CASE OF EMERGENCY: USE YOUR BOOTLOADER TO ROLLBACK LAST SNAPSHOT^^${RESET}"

# --- Update Summary ---
echo -e "${CYAN}+------------------------------------+"
echo "|          UPDATE SUMMARY            |"
echo -e "+------------------------------------+${RESET}"
printf "| %-34s |\n" "Packages updated: $PACKAGES_UPDATED"
printf "| %-34s |\n" "AUR packages updated: $AUR_UPDATED"
printf "| %-34s |\n" "Flatpaks updated: $FLATPAKS_UPDATED"
printf "| %-34s |\n" "Orphans removed: $ORPHANS_REMOVED"
printf "| %-34s |\n" "Cache cleaned: $CACHE_CLEANED"
printf "| %-34s |\n" "Kernel updated: $([ "$KERNEL_UPDATED" = true ] && echo "YES" || echo "NO")"
printf "| %-34s |\n" "GPU drivers updated: $([ "$GPU_UPDATED" = true ] && echo "YES" || echo "NO")"
printf "| %-34s |\n" "Rollback snapshot: $SNAPSHOT_STATUS"
printf "| %-34s |\n" "Time taken: ${MINUTES}m ${SECONDS}s"
echo "+------------------------------------+"
echo -e "${CYAN}Log of this update has been saved to:${RESET}"
echo -e "${BOLD}$LOG_FILE${RESET}"
echo

notify_user "System Updated" "Yeehaw"

read -p "Press Enter to close, space cowboy..."
