#!/bin/bash
# MIT License
# Copyright (c) 2026 sunny
# See LICENSE file for full details

# Credits:
# ASCII art used in this script created by DeXteR/MJP and emojicombos.com

set -Eeuo pipefail

#Variables
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
ORIGINAL_USER=${SUDO_USER:-$USER}
ORIGINAL_UID=$(id -u "$ORIGINAL_USER")
USER_HOME=$(getent passwd "$ORIGINAL_USER" | cut -d: -f6)
APP_DIR="$SCRIPT_DIR"
BRANCH="main"               
LOG_FILE="$USER_HOME/cowboy-update/cowboy-update.log"
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true

# Colors (only if output is a TTY)
if [ -t 1 ]; then
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    BOLD="\e[1m"
    DIM="\e[2m"
    RESET="\e[0m"
else
    RED=""; GREEN=""; YELLOW=""; BLUE=""
    MAGENTA=""; CYAN=""; BOLD=""; DIM=""; RESET=""
fi

# Check last update (BEFORE sudo elevation)
if [ -f "$LOG_FILE" ]; then
    LAST_UPDATE=$(tail -1 "$LOG_FILE" | cut -d'|' -f1 | xargs)
    DAYS_SINCE=$(( ( $(date +%s) - $(date -d "$LAST_UPDATE" +%s) ) / 86400 ))
    if [ $DAYS_SINCE -gt 7 ]; then
        echo -e "${YELLOW}⚠️  It's been $DAYS_SINCE days since your last update!${RESET}"
        echo ""
    fi
fi

# Relaunch as root if not already
if [[ $EUID -ne 0 ]]; then
    echo -e "${BOLD}-----Cowboy Update requires sudo privileges to run!-----${RESET}"
    exec sudo "$0" "$@"
fi

# Keep sudo alive in background
keep_sudo_alive() {
    while true; do
        sudo -v
        sleep 50
    done
}
# Start background process to keep sudo alive
keep_sudo_alive &
SUDO_KEEPER_PID=$!
# Kill the sudo keeper when script exits
trap 'kill $SUDO_KEEPER_PID 2>/dev/null; echo "Error on line $LINENO. Exiting."; exit 1' ERR
trap 'kill $SUDO_KEEPER_PID 2>/dev/null' EXIT

notify_user() {
    local title="$1"
    local message="$2"
    local icon="${3:-dialog-information}"
    sudo -u "$ORIGINAL_USER" \
        DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" \
        notify-send -a "Cowboy Update" -i "$icon" "$title" "$message"
}

self_update() {
    # Make sure git exists
    if ! command -v git &>/dev/null; then
        echo "git is required for self-update, skipping..."
        return
    fi
    
    # SCRIPT_DIR is already defined at the top of the script
    if [ ! -d "$SCRIPT_DIR/.git" ]; then
        echo "Error: $SCRIPT_DIR is not a git repository!"
        return
    fi

    cd "$SCRIPT_DIR" || return

    # Fetch latest changes
    git fetch origin "$BRANCH" --quiet

    # Detect if HEAD is detached
    DETACHED=$(git symbolic-ref --quiet --short HEAD || echo "DETACHED")

    if [ "$DETACHED" = "DETACHED" ]; then
        echo -e "\e[33mDetached HEAD detected. Resetting to $BRANCH\e[0m"
        git checkout -B "$BRANCH" "origin/$BRANCH"
    else
        # Make sure local branch exists and tracks remote
        git checkout "$BRANCH" >/dev/null 2>&1 || git checkout -b "$BRANCH" "origin/$BRANCH"
    fi

    LOCAL_HASH=$(git rev-parse HEAD)
    REMOTE_HASH=$(git rev-parse origin/"$BRANCH")

    echo "Local:  $LOCAL_HASH"
    echo "Remote: $REMOTE_HASH"

    if [ "$LOCAL_HASH" != "$REMOTE_HASH" ]; then
        echo -e "\e[33mA new update for Cowboy Update is available!\e[0m"
        read -rp "Do you want to update now? (y/N): " choice
        case "$choice" in
            y|Y)
                echo -e "\e[32mUpdating Cowboy Update...\e[0m"

                # Stash local changes if any
                STASHED=false
                if ! git diff-index --quiet HEAD --; then
                    git stash push -q -u -m "cowboy-update-autostash-$(date +%F_%H%M%S)"
                    STASHED=true
                fi

                # Force reset to remote branch
                git reset --hard "origin/$BRANCH"
                git clean -fd

                # Reapply stash if needed
                if [ "$STASHED" = true ]; then
                    git stash pop -q 2>/dev/null || echo "Could not reapply stashed changes"
                fi

                echo -e "\e[32mUpdate pulled successfully! New commit: $(git rev-parse HEAD)\e[0m"

                echo -e "\e[32mUpdate complete! Relaunching...\e[0m"
                # Get the full path to the script
                SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
                exec "$SCRIPT_PATH" "$@"
                ;;
            *)
                echo -e "${YELLOW}Update skipped.${RESET}"
                ;;
        esac
    else
        echo -e "${GREEN}Cowboy-update is already on the latest version.${RESET}"
    fi
}

warn_large_update() {
    # Get list of packages that would be upgraded
    UPDATE_LIST=$(checkupdates 2>/dev/null || true)
    
    # Only count if we got results
    if [ -n "$UPDATE_LIST" ]; then
        NUM_UPDATES=$(echo "$UPDATE_LIST" | wc -l)
        
        if [ "$NUM_UPDATES" -gt 20 ]; then
            echo -e "${YELLOW}⚠️  There are $NUM_UPDATES packages to update.${RESET}"
            echo -e "${YELLOW}This is a large update and may take a while.${RESET}"
            read -p "Do you want to proceed with the update? (y/n): " proceed
            if [[ ! "$proceed" =~ ^[Yy]$ ]]; then
                echo -e "${GREEN}Update canceled.${RESET}"
                exit 0
            fi
        fi
    fi
}

check_disk_space() {
    AVAILABLE_SPACE=$(df / | tail -1 | awk '{print $4}')
    AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
    
    if [ $AVAILABLE_GB -lt 5 ]; then
        echo ""
        echo -e "${RED}⚠️  WARNING: Only ${AVAILABLE_GB}GB free space available!${RESET}"
        echo "Recommended: At least 5GB free for safe updates"
        read -p "Continue anyway? (y/N): " continue_update
        if [[ ! "$continue_update" =~ ^[Yy]$ ]]; then
            echo "Update cancelled. Free up some space first."
            exit 0
        fi
    fi
}
reboot_prompt() {
    if [[ "$KERNEL_UPDATED" = true || "$GPU_UPDATED" = true ]]; then
        read -p "Reboot recommended. Reboot now? (y/N): " choice
        [[ "$choice" =~ ^[Yy]$ ]] && reboot
    fi
}

log_summary() {
    echo "$(date '+%F %T') | Time: ${MINUTES}m ${SECONDS}s | Packages: $PACKAGES_UPDATED | AUR: $AUR_UPDATED | Flatpaks: $FLATPAKS_UPDATED | Orphans: $ORPHANS_REMOVED | Cache: $CACHE_CLEANED | Kernel: $([ "$KERNEL_UPDATED" = true ] && echo YES || echo NO) | GPU: $([ "$GPU_UPDATED" = true ] && echo YES || echo NO)" >> "$LOG_FILE"
}

report_pacnew_files() {
    PACNEW_COUNT=$(find /etc -name "*.pacnew" 2>/dev/null | wc -l)
    PACSAVE_COUNT=$(find /etc -name "*.pacsave" 2>/dev/null | wc -l)

    if [ "$PACNEW_COUNT" -eq 0 ] && [ "$PACSAVE_COUNT" -eq 0 ]; then
        return
    fi

    echo
    echo -e "${YELLOW}⚠️  Config files need review${RESET}"
    echo "  .pacnew files:  $PACNEW_COUNT"
    echo "  .pacsave files: $PACSAVE_COUNT"
    echo
    echo "Nothing was overwritten."
    echo "Review later with:"
    echo "  sudo pacdiff"
    echo

    echo "$(date '+%F %T') | PACNEW | $PACNEW_COUNT pacnew | $PACSAVE_COUNT pacsave" >> "$LOG_FILE"
}

# Verify pacman database isn't corrupted
check_database_health() {
    echo "Checking pacman database integrity..."

    # pacman -Qk returns non-zero when missing files exist (normal)
    DB_OUTPUT=$(pacman -Qk 2>/dev/null || true)

    # Extract ONLY package summary lines with missing files
    BAD_PKGS=$(echo "$DB_OUTPUT" \
        | grep -E "missing file[s]?\)$" \
        | grep -v ": 0 missing" \
        || true)

    if [ -z "$BAD_PKGS" ]; then
        echo -e "${GREEN}✓ Database is healthy${RESET}"
        echo "$(date '+%F %T') | DB CHECK | OK | 0 packages affected" >> "$LOG_FILE"
        return 0
    fi

    PKG_COUNT=$(echo "$BAD_PKGS" | wc -l)

    echo -e "${YELLOW}⚠️  $PKG_COUNT package(s) with missing files detected${RESET}"
    echo
    echo "$BAD_PKGS"
    echo

    if [ "$PKG_COUNT" -le 3 ]; then
        echo -e "${DIM}This is very common on Arch and usually harmless.${RESET}"
        echo -e "${DIM}Optional fix:${RESET}"
        echo -e "${DIM}  sudo pacman -Syu --overwrite '*'${RESET}"
        SEVERITY="LOW"
    else
        echo -e "${RED}⚠️  Multiple packages affected — investigate.${RESET}"
        SEVERITY="HIGH"
    fi

    echo "$(date '+%F %T') | DB CHECK | $SEVERITY | $PKG_COUNT packages affected" >> "$LOG_FILE"
}

echo -e "${CYAN}
╔══════════════════════════════════╗
║                                  ║
║                                  ║
║       COWBOY-UPDATE SCRIPT       ║
║                                  ║
║              sunny               ║
╚══════════════════════════════════╝${RESET}"
cat <<'EOF'
  (                                 _
   )                               /=>
  (  +____________________/\/\___ / /|
   .''._____________'._____      / /|/\
  : () :              :\ ----\|    \ )
   '..'______________.'0|----|      \
                    0_0/____/        \
                        |----    /----\
                       || -\\ --|      \
                       ||   || ||\      \
                        \\____// '|      \
                                .'/       |
                               .:/        |
                               :/_________|
EOF
read -p "Press Enter to begin..."

self_update

# Track stats
PACKAGES_UPDATED=0
AUR_UPDATED=0
FLATPAKS_UPDATED=0
ORPHANS_REMOVED=0
CACHE_CLEANED="0 MB"
START_TIME=$(date +%s)

print_failure_art() {
cat <<'EOF'
⠀⠀⢀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯
⠀⠀⢩⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠘⢿⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⣿⠟⠋⠀
⠀⢴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⣿⣿⡿⠿⣿⡿⢻⠟⣿⡟⠀⠈⠀⠙⠷⡝⠿⣝⠛⠛⠉⠛⠻⠿⠟⢿⣿⡿⠄⠀⠀⠀⠀⠀⠀
⠶⠿⢿⣿⣿⣿⣿⣿⣿⣿⢻⡿⠁⠀⠀⠉⠀⠀⠀⠀⠀⠀⡼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠛⠿⣿⣿⣿⡿⢿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢚⣽⡟⠛⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠍⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢷⡄⠀⠀⢴⣄⠘⠃⠀⠀⠀⠻⣿⡋⢀⢀⢀⡀⠀⠀⠀⠀⣿⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⠀⢠⣶⣶⣦⣤⣴⣚⣽⡏⣿⣿⣿⣿⣶⣭⣤⣄⠀⠀⣼⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⡜⡿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⡆⠀⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⣶⣦⣝⣿⣿⡏⣼⣿⣿⣿⠘⣿⣿⣿⣿⣿⣿⣿⡇⠀⢹⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠿⡛⠁⣿⣿⣿⠈⠻⢙⢿⣿⣿⡟⠀⣿⣿⣿⣿⣿⣿⣿⠁⣿⡌⠃⠀⠀⢀⣿⣦⣀⠀⢀⣴⣿⣷⣦⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢘⣵⣿⣷⣼⣿⣿⡟⠀⢠⣿⣷⠙⣿⣧⡀⢿⣿⣿⣿⣿⣿⣿⡸⣿⠀⠀⠀⠀⣾⣿⣿⣿⣷⣝⢿⣿⣿⣿⣿
⠀⠀⢀⣀⣠⣤⣴⣶⠶⢟⣼⣿⠿⠿⠿⠟⠋⠀⠀⢹⡿⠃⢠⣿⣿⣿⣿⣿⣿⠿⢟⣫⣿⣇⠏⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣷⣮⡻⣿⣿
⣾⣿⣿⣿⣿⣿⣿⣆⢸⣿⣿⣿⣿⣿⣿⣶⣶⣶⣤⣘⡀⠀⠈⠻⣿⣿⠿⠿⠾⠿⢛⣿⣿⠃⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⠟⢠⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡎⣿⣿⡿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⡘⢿⣷⣶⣶⣶⣿⣿⡏⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⡿⠛⠁⣠⣾⣿⣿
⣿⣿⣿⣿⣿⣿⡻⠟⢸⣿⣿⣿⣿⣶⣮⣭⣟⣛⣛⠿⣿⣿⠏⠉⠙⠷⣝⣿⣿⣿⣿⠟⠀⠀⠀⠀⣠⣿⣿⣿⣿⠟⠉⠀⣠⣾⣿⣿⣿⣿
⠉⠉⠛⠻⠿⣿⣿⣷⡄⠙⠿⠿⢿⣿⣿⣿⣿⣿⠛⠋⠀⠀⠀⠀⠀⠀⠀⠈⠛⠉⠀⠀⠀⠀⠀⣰⣿⡿⠟⠋⠁⠀⣠⣾⣿⣿⣿⣿⣿⣿
⠿⠷⢶⠦⠀⠈⠛⣽⡇⠀⠀⠀⣀⣀⣈⡉⠙⠛⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⢠⣾⠟⠁⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⠟
⣴⣾⣿⠿⢂⢰⢷⣿⡄⠀⠀⠀⠀⠙⠻⠿⣿⣶⠶⠄⠀⠀⠀⣴⣾⣷⠀⠀⠀⠀⠀⠀⢰⣿⡟⠀⠀⠀⠀⡀⠀⢸⣿⣿⣿⣿⣿⡿⠋⠀
⠟⠉⣠⣾⡟⣾⣼⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡄⠀⡄⠀⠀⣽⣿⣦⡀⠀⠀⠀⢀⣿⣿⡇⠀⠀⠀⢀⣿⡀⠈⣿⣿⣿⣿⡟⠁⠀⠀
⢠⣾⣿⣿⢣⣿⣿⡟⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⢻⡀⠈⠛⠿⣯⡀⠀⠀⢀⣾⡿⠿⠃⣠⡆⠀⠀⣿⣧⠀⢹⣿⣿⣿⣷⣄⠀⠀
⣿⣿⣿⣿⣸⣿⢹⣷⡙⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣦⡀⠀⢠⡉⠃⢠⢋⣤⠀⢠⣾⣿⡇⠀⢀⠘⣿⡄⠈⣿⣿⣿⣿⣿⣷⣤
⣿⣿⣿⣿⣿⣿⡎⢿⣿⡌⠻⣷⡄⠀⠀⠀⠀⠀⠀⠀⢰⢹⣿⣿⣿⣦⡀⠻⣤⣦⣾⢃⣴⣿⣿⣿⠃⠀⢸⣆⠘⠇⠀⢹⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡈⠛⠋⠀⠈⠙⠆⠀⠀⠀⠀⠀⠀⠁⠀⣿⣿⣿⣿⣿⡄⣿⣿⣿⣿⣿⣿⣿⠃⣼⠁⠀⣿⣿⣶⡄⠘⣿⣿⣿⣿⣿⣿
EOF
}

# Check Arch news
echo
echo -e "${BOLD}Checking recent Arch news...${RESET}"
curl -s https://archlinux.org/feeds/news/ | grep -oP '(?<=<title>).*?(?=</title>)' | head -n 5 | tail -n 4
echo ""
read -p "Press Enter to continue with updates..."
echo

# Track if kernel or GPU drivers were updated during this run
KERNEL_UPDATED=false
GPU_UPDATED=false

warn_large_update
check_disk_space
check_database_health

# Update official repos
echo
echo "======================================="
echo -e "${GREEN}Updating Official Repository...${RESET}"
echo "======================================="
# Capture pacman output to check if kernel was updated
PACMAN_LOG=$(mktemp)

# Run pacman (disable exit-on-error for this command)
set +e
script -q -c "pacman -Syu" "$PACMAN_LOG"
PACMAN_EXIT=$?
set -e

PACMAN_OUTPUT=$(cat "$PACMAN_LOG")
rm "$PACMAN_LOG"

# Count packages updated (handle case where grep finds nothing)
if echo "$PACMAN_OUTPUT" | grep -q "upgrading"; then
    PACKAGES_UPDATED=$(echo "$PACMAN_OUTPUT" | grep -c "upgrading")
else
    PACKAGES_UPDATED=0
fi

# Check for any kernel package update (CachyOS or standard Arch)
if echo "$PACMAN_OUTPUT" | grep -qE 'upgrading linux(-|$)'; then
    KERNEL_UPDATED=true
fi

# Check for GPU driver updates (NVIDIA, AMD, Intel)
if echo "$PACMAN_OUTPUT" | grep -qE 'upgrading (nvidia|mesa|xf86-video|vulkan-|amdgpu)'; then
    GPU_UPDATED=true
fi

if [ $PACMAN_EXIT -ne 0 ] || echo "$PACMAN_OUTPUT" | tail -5 | grep -qi "error\|failed"; then
        echo -e "${YELLOW}pacman failed!${RESET}"
        print_failure_art
        notify_user "Update Failed" "pacman failed" cowboy-icon
fi

echo
echo "======================================="
echo -e "${GREEN}Updating AUR Packages...${RESET}"
echo "======================================="
set +e
AUR_OUTPUT=$(sudo -u "$ORIGINAL_USER" paru -Sua 2>&1 | tee /dev/tty)
PARU_EXIT=$?
set -e

# Count AUR packages updated
if echo "$AUR_OUTPUT" | grep -q "upgrading"; then
    AUR_UPDATED=$(echo "$AUR_OUTPUT" | grep -c "upgrading")
else
    AUR_UPDATED=0
fi

if [ $PARU_EXIT -ne 0 ]; then
    echo -e "${YELLOW}paru failed!${RESET}"
    print_failure_art
    notify_user "Update Failed" "paru failed" cowboy-icon
fi

echo
echo "======================================="
echo -e "${GREEN}Updating Flatpaks...${RESET}"
echo "======================================="

# Update system-level flatpaks (as root)
echo "Updating system flatpaks..."
set +e
FLATPAK_SYSTEM_OUTPUT=$(flatpak update --system -y 2>&1 | tee /dev/tty)
FLATPAK_SYSTEM_EXIT=$?
set -e

# Update user-level flatpaks (as original user)
echo "Updating user flatpaks..."
set +e
FLATPAK_USER_OUTPUT=$(sudo -u "$ORIGINAL_USER" DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" flatpak update --user -y 2>&1 | tee /dev/tty)
FLATPAK_USER_EXIT=$?
set -e

# Count updates from both outputs
SYSTEM_COUNT=0
USER_COUNT=0
if echo "$FLATPAK_SYSTEM_OUTPUT" | grep -q "Installing\|Updating"; then
    SYSTEM_COUNT=$(echo "$FLATPAK_SYSTEM_OUTPUT" | grep -c "Installing\|Updating")
fi
if echo "$FLATPAK_USER_OUTPUT" | grep -q "Installing\|Updating"; then
    USER_COUNT=$(echo "$FLATPAK_USER_OUTPUT" | grep -c "Installing\|Updating")
fi
FLATPAKS_UPDATED=$((SYSTEM_COUNT + USER_COUNT))

# Check if either failed
if [ $FLATPAK_SYSTEM_EXIT -ne 0 ] || [ $FLATPAK_USER_EXIT -ne 0 ]; then
    echo -e "${YELLOW}flatpak update failed!${RESET}"
    print_failure_art
    notify_user "Update Failed" "flatpak failed" cowboy-icon
fi

echo
echo "======================================="
echo -e "${YELLOW}Cleaning...${RESET}"
echo "======================================="
# Show disk space saved - var before
BEFORE=$(df / | tail -1 | awk '{print $4}')

# Check for orphaned packages
echo
echo "Checking for orphaned packages..."
echo
ORPHANS=$(pacman -Qtdq 2>/dev/null || true)
if [ -n "$ORPHANS" ]; then
    ORPHANS_REMOVED=$(echo "$ORPHANS" | wc -l)
    ORPHANS_REMOVED=${ORPHANS_REMOVED//[^0-9]/}  # Keep only digits
    echo "Found orphaned packages:"
    echo "$ORPHANS"
    read -p "Remove them? (y/n): " choice
    if [[ $choice == "y" || $choice == "Y" ]]; then
        set +e
        pacman -Rns $ORPHANS --noconfirm
        set -e
    else
        ORPHANS_REMOVED=0
    fi
else
    echo "No orphaned packages found."
    echo
    ORPHANS_REMOVED=0
fi

# Clean package cache (keep last 2 versions)
echo "Cleaning package cache..."
echo
if command -v paccache &> /dev/null; then

    CACHE_BEFORE=$(du -sm /var/cache/pacman/pkg/ | awk '{print $1}')
    
    paccache -rk2 > /dev/null 2>&1
    paccache -ruk0 > /dev/null 2>&1
    
    CACHE_AFTER=$(du -sm /var/cache/pacman/pkg/ | awk '{print $1}')
    CACHE_CLEANED="$((CACHE_BEFORE - CACHE_AFTER)) MB"
else
    echo "paccache not found (install pacman-contrib)"
    CACHE_CLEANED="0 MB"
fi

# Clean Flatpak cache
if command -v flatpak &> /dev/null; then
    echo "Cleaning Flatpak cache..."
    echo
    # Clean system flatpaks
    flatpak uninstall --system --unused -y > /dev/null 2>&1
    # Clean user flatpaks
    sudo -u "$ORIGINAL_USER" DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" flatpak uninstall --user --unused -y > /dev/null 2>&1
fi

report_pacnew_files

# List services using old libraries
if command -v needrestart &> /dev/null; then
    echo "Checking for services needing restart..."
    needrestart -l
fi

# ... do updates and cleaning results...
AFTER=$(df / | tail -1 | awk '{print $4}')
SAVED=$((AFTER - BEFORE))
echo
echo "Freed up: $((SAVED / 1024)) MB"

# Check if reboot needed
if [ "$KERNEL_UPDATED" = true ] || [ "$GPU_UPDATED" = true ]; then
    echo
    echo "⚠️  ========================================== ⚠️"
    echo "⚠️           REBOOT RECOMMENDED              ⚠️"
    echo "⚠️  ========================================== ⚠️"
    
    if [ "$KERNEL_UPDATED" = true ] && [ "$GPU_UPDATED" = true ]; then
        echo "   Kernel AND GPU drivers were updated!"
        notify_user "Reboot Recommended" "Kernel and GPU drivers updated" dialog-warning
    elif [ "$KERNEL_UPDATED" = true ]; then
        echo "   Kernel was updated!"
        notify_user "Reboot Recommended" "Kernel was updated" dialog-warning
    else
        echo "   GPU drivers were updated!"
        notify_user "Reboot Recommended" "GPU drivers updated" dialog-warning
    fi
    
    echo "⚠️  ========================================== ⚠️"
    echo
fi

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))
MINUTES=$((DURATION / 60))
SECONDS=$((DURATION % 60))

log_summary
reboot_prompt

echo "+------------------------------------+"
echo -e "|${GREEN} SUCCESS! YOU CARRIED THAT WEIGHT!${RESET}  |"
echo "+------------------------------------+"
    echo -e "${BOLD}⣿⣿⣿⣿⣿⡿⠛⠋⠙⠉⠋⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⢿⣿⣿⣿⣿
⣿⣿⣿⣿⣥⣴⣶⣿⣿⣿⣿⣷⣦⡈⠙⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⣁⣤⣤⣶⣶⣤⣤⣈⣻⣿⣿
⣿⣿⣿⣿⡿⠿⠛⠛⠻⠿⣿⣿⣿⣿⣧⣈⣿⣿⣿⣿⣿⣿⠏⣡⣾⣿⣿⣿⣿⡿⠿⢿⣿⣿⣿⣿
⣿⣿⣿⡏⠀⡀⠂⠄⡁⠐⢘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠉⠀⡀⠄⠠⠀⠙⣿⣿
⣿⡿⢿⣷⣦⣤⣥⣴⣤⣵⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣁⣀⣂⣁⣬⣴⡿⢿
⣿⠀⣦⣉⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⣡⣴⠈
⣧⠀⣿⣿⢰⣦⣬⣉⠛⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠟⠋⣉⣤⣶⢐⣿⣿⠀
⣿⠀⣿⡿⢸⣿⣿⣿⣿⠀⣤⣤⣍⣉⣙⠙⠛⠛⠛⠛⠛⠉⣉⣉⣥⣤⣤⠀⣿⣿⣿⣿⢸⣿⡟⢠
⣿⡄⢻⡇⢸⣿⣿⣿⣿⠀⣿⣿⣿⣿⣿⠀⣿⣿⣿⣿⡿⠀⣿⣿⣿⣿⡇⠠⣿⣿⣿⡿⢸⣿⠇⣼
⣿⣷⡈⠇⢸⣿⣿⣿⣿⠀⣿⣿⣿⣿⣿⠀⣿⣿⣿⣿⡇⢈⣿⣿⣿⣿⡇⢸⣿⣿⣿⡇⢸⡟⢠⣿
⣿⣿⣷⡀⢸⣿⣿⣿⣿⠀⣿⣿⣿⣿⣿⠀⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⡇⢸⣿⣿⣿⡇⠘⢠⣿⣿
⣿⣿⣿⣷⣌⠻⣿⣿⣿⠀⣿⣿⣿⣿⣿⠀⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⡇⢸⣿⣿⡿⠃⣰⣿⣿⣿
⣿⣿⣿⣿⣿⣧⡈⠻⡏⠠⣿⣿⣿⣿⡏⠐⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⡇⢸⡿⠛⣡⣾⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄⡐⠻⢿⣿⣿⡇⢨⣿⣿⣿⣿⡇⢸⣿⣿⣿⡿⠃⣈⣤⣾⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣬⣉⣃⠘⠛⠛⠛⠛⠃⠘⣛⣉⣥⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿${RESET}"

#Summary
echo -e "${CYAN}+------------------------------------+"
echo "|         UPDATE SUMMARY             |"
echo -e "+------------------------------------+${RESET}"
printf "| %-34s |\n" "Packages updated: $PACKAGES_UPDATED"
printf "| %-34s |\n" "AUR packages updated: $AUR_UPDATED"
printf "| %-34s |\n" "Flatpaks updated: $FLATPAKS_UPDATED"
printf "| %-34s |\n" "Orphans removed: $ORPHANS_REMOVED"
printf "| %-34s |\n" "Cache cleaned: $CACHE_CLEANED"
printf "| %-34s |\n" "Kernel updated: $([ "$KERNEL_UPDATED" = true ] && echo "YES" || echo "NO")"
printf "| %-34s |\n" "GPU drivers updated: $([ "$GPU_UPDATED" = true ] && echo "YES" || echo "NO")"
printf "| %-34s |\n" "Time taken: ${MINUTES}m ${SECONDS}s"
echo "+------------------------------------+"

notify_user "System Updated" "Yeehaw"

read -p "Press Enter to close, space cowboy..."
