#!/bin/bash
# MIT License
# Copyright (c) 2026 sunny
# See LICENSE file for full details

# Credits:
# ASCII art used in this script created by DeXteR/MJP and emojicombos.com

set -Eeuo pipefail

#Variables
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
ORIGINAL_USER=${SUDO_USER:-$USER}
ORIGINAL_UID=$(id -u "$ORIGINAL_USER")
USER_HOME=$(getent passwd "$ORIGINAL_USER" | cut -d: -f6)
APP_DIR="$SCRIPT_DIR"
BRANCH="main"               
LOG_FILE="$USER_HOME/cowboy-update/cowboy-update.log"
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true

# Get version from git tag if available
if command -v git &>/dev/null && [ -d "$SCRIPT_DIR/.git" ]; then
    pushd "$SCRIPT_DIR" > /dev/null
    VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "dev")
    popd > /dev/null
else
    VERSION="unknown"
fi


# Colors (only if output is a TTY)
if [ -t 1 ]; then
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    BOLD="\e[1m"
    DIM="\e[2m"
    RESET="\e[0m"
else
    RED=""; GREEN=""; YELLOW=""; BLUE=""
    MAGENTA=""; CYAN=""; BOLD=""; DIM=""; RESET=""
fi

# Check last update (BEFORE sudo elevation)
if [ -f "$LOG_FILE" ]; then
    LAST_UPDATE=$(tail -1 "$LOG_FILE" | cut -d'|' -f1 | xargs)
    DAYS_SINCE=$(( ( $(date +%s) - $(date -d "$LAST_UPDATE" +%s) ) / 86400 ))
    if [ $DAYS_SINCE -gt 7 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  It's been $DAYS_SINCE days since your last update!${RESET}"
        echo ""
    fi
fi

# Relaunch as root if not already
if [[ $EUID -ne 0 ]]; then
    echo -e "${BOLD}-----Cowboy Update requires sudo privileges to run!-----${RESET}"
    exec sudo "$0" "$@"
fi

# Keep sudo alive in background
keep_sudo_alive() {
    while true; do
        sudo -v
        sleep 50
    done
}
# Start background process to keep sudo alive
keep_sudo_alive &
SUDO_KEEPER_PID=$!
# Kill the sudo keeper when script exits
trap 'kill $SUDO_KEEPER_PID 2>/dev/null; echo "Error on line $LINENO. Exiting."; exit 1' ERR
trap 'kill $SUDO_KEEPER_PID 2>/dev/null' EXIT

print_failure_art() {
cat <<'EOF'
‚†Ä‚†Ä‚¢Ä‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø
‚†Ä‚†Ä‚¢©‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ò‚¢ø‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚£ø‚†ü‚†ã‚†Ä
‚†Ä‚¢¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†õ‚£ø‚£ø‚°ø‚†ø‚£ø‚°ø‚¢ª‚†ü‚£ø‚°ü‚†Ä‚†à‚†Ä‚†ô‚†∑‚°ù‚†ø‚£ù‚†õ‚†õ‚†â‚†õ‚†ª‚†ø‚†ü‚¢ø‚£ø‚°ø‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†∂‚†ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ª‚°ø‚†Å‚†Ä‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°º‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†õ‚†ø‚£ø‚£ø‚£ø‚°ø‚¢ø‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚¢ö‚£Ω‚°ü‚†õ‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∑‚°Ñ‚†Ä‚†Ä‚¢¥‚£Ñ‚†ò‚†É‚†Ä‚†Ä‚†Ä‚†ª‚£ø‚°ã‚¢Ä‚¢Ä‚¢Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ª‚†Ä‚¢†‚£∂‚£∂‚£¶‚£§‚£¥‚£ö‚£Ω‚°è‚£ø‚£ø‚£ø‚£ø‚£∂‚£≠‚£§‚£Ñ‚†Ä‚†Ä‚£º‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ø‚£ø‚°ú‚°ø‚£ø‚£ø‚£ø‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ü‚†Ä‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∂‚£¶‚£ù‚£ø‚£ø‚°è‚£º‚£ø‚£ø‚£ø‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚†Ä‚¢π‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚†ø‚°õ‚†Å‚£ø‚£ø‚£ø‚†à‚†ª‚¢ô‚¢ø‚£ø‚£ø‚°ü‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Å‚£ø‚°å‚†É‚†Ä‚†Ä‚¢Ä‚£ø‚£¶‚£Ä‚†Ä‚¢Ä‚£¥‚£ø‚£∑‚£¶‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ò‚£µ‚£ø‚£∑‚£º‚£ø‚£ø‚°ü‚†Ä‚¢†‚£ø‚£∑‚†ô‚£ø‚£ß‚°Ä‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°∏‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£∑‚£ù‚¢ø‚£ø‚£ø‚£ø‚£ø
‚†Ä‚†Ä‚¢Ä‚£Ä‚£†‚£§‚£¥‚£∂‚†∂‚¢ü‚£º‚£ø‚†ø‚†ø‚†ø‚†ü‚†ã‚†Ä‚†Ä‚¢π‚°ø‚†É‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚¢ü‚£´‚£ø‚£á‚†è‚†Ä‚†Ä‚†Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Æ‚°ª‚£ø‚£ø
‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ü‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∂‚£∂‚£∂‚£§‚£ò‚°Ä‚†Ä‚†à‚†ª‚£ø‚£ø‚†ø‚†ø‚†æ‚†ø‚¢õ‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚¢†‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°é‚£ø‚£ø‚°ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£∂‚£§‚°ò‚¢ø‚£∑‚£∂‚£∂‚£∂‚£ø‚£ø‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚†Å‚£†‚£æ‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ª‚†ü‚¢∏‚£ø‚£ø‚£ø‚£ø‚£∂‚£Æ‚£≠‚£ü‚£õ‚£õ‚†ø‚£ø‚£ø‚†è‚†â‚†ô‚†∑‚£ù‚£ø‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£ø‚£ø‚£ø‚£ø‚†ü‚†â‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø
‚†â‚†â‚†õ‚†ª‚†ø‚£ø‚£ø‚£∑‚°Ñ‚†ô‚†ø‚†ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†õ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∞‚£ø‚°ø‚†ü‚†ã‚†Å‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚†ø‚†∑‚¢∂‚†¶‚†Ä‚†à‚†õ‚£Ω‚°á‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚£à‚°â‚†ô‚†õ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü
‚£¥‚£æ‚£ø‚†ø‚¢Ç‚¢∞‚¢∑‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†ª‚†ø‚£ø‚£∂‚†∂‚†Ñ‚†Ä‚†Ä‚†Ä‚£¥‚£æ‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†ã‚†Ä
‚†ü‚†â‚£†‚£æ‚°ü‚£æ‚£º‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚°Ñ‚†Ä‚†Ä‚£Ω‚£ø‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚°Ä‚†à‚£ø‚£ø‚£ø‚£ø‚°ü‚†Å‚†Ä‚†Ä
‚¢†‚£æ‚£ø‚£ø‚¢£‚£ø‚£ø‚°ü‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†É‚†Ä‚¢ª‚°Ä‚†à‚†õ‚†ø‚£Ø‚°Ä‚†Ä‚†Ä‚¢Ä‚£æ‚°ø‚†ø‚†É‚£†‚°Ü‚†Ä‚†Ä‚£ø‚£ß‚†Ä‚¢π‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä
‚£ø‚£ø‚£ø‚£ø‚£∏‚£ø‚¢π‚£∑‚°ô‚£ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚£ø‚£¶‚°Ä‚†Ä‚¢†‚°â‚†É‚¢†‚¢ã‚£§‚†Ä‚¢†‚£æ‚£ø‚°á‚†Ä‚¢Ä‚†ò‚£ø‚°Ñ‚†à‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£§
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°é‚¢ø‚£ø‚°å‚†ª‚£∑‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚¢π‚£ø‚£ø‚£ø‚£¶‚°Ä‚†ª‚£§‚£¶‚£æ‚¢É‚£¥‚£ø‚£ø‚£ø‚†É‚†Ä‚¢∏‚£Ü‚†ò‚†á‚†Ä‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°à‚†õ‚†ã‚†Ä‚†à‚†ô‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†É‚£º‚†Å‚†Ä‚£ø‚£ø‚£∂‚°Ñ‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
EOF
}

warn() {
    local msg="$1"
    echo -e "${YELLOW}‚ö†Ô∏è  WARNING: $msg${RESET}"
    echo "$(date '+%F %T') | WARN | $msg" >> "$LOG_FILE"
}

fatal() {
    local msg="$1"
    echo -e "${RED}‚ùå FATAL: $msg${RESET}"
    echo "$(date '+%F %T') | FATAL | $msg" >> "$LOG_FILE"
    notify_user "Update Failed" "$msg" cowboy-icon
    exit 1
}

notify_user() {
    local title="$1"
    local message="$2"
    local icon="${3:-dialog-information}"
    sudo -u "$ORIGINAL_USER" \
        DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" \
        notify-send -a "Cowboy Update" -i "$icon" "$title" "$message"
}

self_update() {
    # Make sure git exists
    if ! command -v git &>/dev/null; then
        echo "git is required for self-update, skipping..."
        return
    fi
    
    # SCRIPT_DIR is already defined at the top of the script
    if [ ! -d "$SCRIPT_DIR/.git" ]; then
        echo "Error: $SCRIPT_DIR is not a git repository!"
        return
    fi

    cd "$SCRIPT_DIR" || return

    # Fetch latest changes
    git fetch origin "$BRANCH" --quiet

    # Detect if HEAD is detached
    DETACHED=$(git symbolic-ref --quiet --short HEAD || echo "DETACHED")

    if [ "$DETACHED" = "DETACHED" ]; then
        echo -e "\e[33mDetached HEAD detected. Resetting to $BRANCH\e[0m"
        git checkout -B "$BRANCH" "origin/$BRANCH"
    else
        # Make sure local branch exists and tracks remote
        git checkout "$BRANCH" >/dev/null 2>&1 || git checkout -b "$BRANCH" "origin/$BRANCH"
    fi

    LOCAL_HASH=$(git rev-parse HEAD)
    REMOTE_HASH=$(git rev-parse origin/"$BRANCH")

    echo "Local:  $LOCAL_HASH"
    echo "Remote: $REMOTE_HASH"

    if [ "$LOCAL_HASH" != "$REMOTE_HASH" ]; then
        echo -e "\e[33mA new update for Cowboy Update is available!\e[0m"
        read -rp "Do you want to update now? (y/N): " choice
        case "$choice" in
            y|Y)
                echo -e "\e[32mUpdating Cowboy Update...\e[0m"

                # Stash local changes if any
                STASHED=false
                if ! git diff-index --quiet HEAD --; then
                    git stash push -q -u -m "cowboy-update-autostash-$(date +%F_%H%M%S)"
                    STASHED=true
                fi

                # Force reset to remote branch
                git reset --hard "origin/$BRANCH"
                git clean -fd

                # Reapply stash if needed
                if [ "$STASHED" = true ]; then
                    git stash pop -q 2>/dev/null || echo "Could not reapply stashed changes"
                fi

                echo -e "\e[32mUpdate pulled successfully! New commit: $(git rev-parse HEAD)\e[0m"

                echo -e "\e[32mUpdate complete! Relaunching...\e[0m"
                # Get the full path to the script
                SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
                exec "$SCRIPT_PATH" "$@"
                ;;
            *)
                echo -e "${YELLOW}Update skipped.${RESET}"
                ;;
        esac
    else
        echo -e "${GREEN}Cowboy-update is already on the latest version.${RESET}"
    fi
}

backup_pacman_db() {
    local backup_dir="$USER_HOME/cowboy-update/pacman-backup"
    mkdir -p "$backup_dir"

    # Remove backups older than 30 days
    find "$backup_dir" -type f -name "pacman-db-*.tar.gz" -mtime +30 -exec rm -v {} \; 2>/dev/null

    local timestamp
    timestamp=$(date +%F_%H%M%S)
    local backup_file="$backup_dir/pacman-db-$timestamp.tar.gz"

    echo -e "${YELLOW}‚è≥ Backing up pacman database...${RESET}"

    # Backup local and sync databases
    if sudo tar -czf "$backup_file" /var/lib/pacman/local /var/lib/pacman/sync; then
        echo -e "${GREEN}‚úì Pacman database backup saved to $backup_file${RESET}"
        echo -e "${DIM}Backups older than 30 days have been cleaned automatically.${RESET}"
        echo
        echo -e "${CYAN}üí° Tip: To inspect or restore a backup if needed:${RESET}"
        echo -e "${CYAN}   Inspect package info: tar -xzf $backup_file -C /tmp && pacman -Qkk /tmp/local/*${RESET}"
        echo -e "${CYAN}   Restore pacman DB: sudo tar -xzf $backup_file -C /${RESET}"
    else
        warn "Pacman database backup failed"
    fi
}

warn_large_update() {
    # Get list of packages that would be upgraded
    UPDATE_LIST=$(checkupdates 2>/dev/null || true)

    # Only count if we got results
    if [ -n "$UPDATE_LIST" ]; then
        NUM_UPDATES=$(echo "$UPDATE_LIST" | wc -l)

        # Threshold for "large update"
        LARGE_UPDATE_THRESHOLD=50

        if [ "$NUM_UPDATES" -gt $LARGE_UPDATE_THRESHOLD ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  There are $NUM_UPDATES packages to update.${RESET}"
            echo -e "${YELLOW}This is a large update and may take a while.${RESET}"

            # Backup pacman DB only if last backup was >30 days ago
            local backup_dir="$USER_HOME/cowboy-update/pacman-backup"
            local last_backup_file="$backup_dir/.last_backup"

            local need_backup=true
            if [ -f "$last_backup_file" ]; then
                local last_backup_ts
                last_backup_ts=$(cat "$last_backup_file")
                local days_since=$(( ( $(date +%s) - last_backup_ts ) / 86400 ))
                if [ "$days_since" -le 30 ]; then
                    need_backup=false
                fi
            fi

            if [ "$need_backup" = true ]; then
                read -p "Do you want to create a pacman database backup before proceeding? (y/N): " backup_choice
                if [[ "$backup_choice" =~ ^[Yy]$ ]]; then
                    backup_pacman_db
                    # Record backup timestamp
                    mkdir -p "$backup_dir"
                    date +%s > "$last_backup_file"
                else
                    echo -e "${YELLOW}Skipping pacman database backup.${RESET}"
                fi
            else
                echo -e "${CYAN}Pacman DB was backed up recently, skipping backup prompt.${RESET}"
            fi

            read -p "Do you want to proceed with the update? (y/N): " proceed
            if [[ ! "$proceed" =~ ^[Yy]$ ]]; then
                echo -e "${GREEN}Update canceled.${RESET}"
                exit 0
            fi
        fi
    fi
}

check_disk_space() {
    AVAILABLE_SPACE=$(df / | tail -1 | awk '{print $4}')
    AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
    
    if [ $AVAILABLE_GB -lt 5 ]; then
        echo ""
        echo -e "${RED}‚ö†Ô∏è  WARNING: Only ${AVAILABLE_GB}GB free space available!${RESET}"
        echo "Recommended: At least 5GB free for safe updates"
        read -p "Continue anyway? (y/N): " continue_update
        if [[ ! "$continue_update" =~ ^[Yy]$ ]]; then
            echo "Update cancelled. Free up some space first."
            exit 0
        fi
    fi
}
reboot_prompt() {
    if [[ "$KERNEL_UPDATED" = true || "$GPU_UPDATED" = true ]]; then
        read -p "Reboot recommended. Reboot now? (y/N): " choice
        [[ "$choice" =~ ^[Yy]$ ]] && reboot
    fi
}

create_rollback_snapshot() {
    KEEP_SNAPSHOTS=2
    SNAP_DIR="/.snapshots"
    sudo mkdir -p "$SNAP_DIR"

    # Detect root mount
    ROOT_FS=$(findmnt -n -o FSTYPE /)
    if [ "$ROOT_FS" != "btrfs" ]; then
        echo "$(date '+%F %T') | SNAPSHOT | SKIPPED | Root FS is not Btrfs" >> "$LOG_FILE"
        return
    fi

    # Determine absolute path of root subvolume
    ROOT_SUBVOL_PATH=$(btrfs subvolume list / -p | awk '$5=="/"{print $9}' | head -n1)
    [ -z "$ROOT_SUBVOL_PATH" ] && ROOT_SUBVOL_PATH="/"
    [ ! -d "/$ROOT_SUBVOL_PATH" ] && ROOT_SUBVOL_PATH="/"
    ROOT_SUBVOL_PATH="/$ROOT_SUBVOL_PATH"

    # Detect last Cowboy rollback snapshot
    LAST_ROLLBACK=$(find "$SNAP_DIR" -maxdepth 1 -type d -name "cowboy-rollback-*" | sort -r | head -1)
    LAST_SNAP_TS=0
    [ -n "$LAST_ROLLBACK" ] && LAST_SNAP_TS=$(stat -c %Y "$LAST_ROLLBACK" 2>/dev/null || echo 0)
    DAYS_SINCE=$(( ( $(date +%s) - LAST_SNAP_TS ) / 86400 ))

    # Silent skip if recent snapshot exists (<14 days)
    [ "$LAST_SNAP_TS" -ne 0 ] && [ "$DAYS_SINCE" -lt 14 ] && return

    # Ask user to create snapshot
    read -rp "Create a rollback snapshot now? (y/N): " choice
    [[ ! "$choice" =~ ^[Yy]$ ]] && { echo "Skipping rollback snapshot."; return; }

       # Timeshift snapshot (if installed)
    if command -v timeshift &>/dev/null; then
        echo "Creating Timeshift snapshot..."
        if sudo timeshift --create --comments "Cowboy rollback $(date '+%F %H:%M:%S')" --tags D --quiet; then
            echo "$(date '+%F %T') | SNAPSHOT | TIMESHIFT | Success" >> "$LOG_FILE"
            
            # Clean up old Timeshift snapshots tagged with 'D' (daily)
            # Keep only the last 3 Cowboy-created Timeshift snapshots
            TIMESHIFT_SNAPS=$(sudo timeshift --list --scripted | grep "D >" | grep "Cowboy rollback" | awk '{print $2}' | sort -r)
            TIMESHIFT_COUNT=$(echo "$TIMESHIFT_SNAPS" | wc -l)
            
            if [ "$TIMESHIFT_COUNT" -gt "$KEEP_SNAPSHOTS" ]; then
                echo "Cleaning old Timeshift snapshots (keeping last $KEEP_SNAPSHOTS)..."
                echo "$TIMESHIFT_SNAPS" | tail -n +$((KEEP_SNAPSHOTS + 1)) | while read -r snap_name; do
                    if sudo timeshift --delete --snapshot "$snap_name" --quiet; then
                        echo "$(date '+%F %T') | SNAPSHOT | TIMESHIFT | Deleted $snap_name" >> "$LOG_FILE"
                    else
                        warn "Failed to delete Timeshift snapshot: $snap_name"
                    fi
                done
            fi
        else
            warn "Timeshift snapshot creation failed"
        fi
    fi

    # Btrfs snapshot
    SNAP_NAME="cowboy-rollback-$(date '+%F_%H%M%S')"
    SNAP_PATH="$SNAP_DIR/$SNAP_NAME"
    if sudo btrfs subvolume snapshot -r "$ROOT_SUBVOL_PATH" "$SNAP_PATH"; then
        echo "$(date '+%F %T') | SNAPSHOT | BTRFS | Created at $SNAP_PATH" >> "$LOG_FILE"
    else
        echo "$(date '+%F %T') | SNAPSHOT | BTRFS | FAILED" >> "$LOG_FILE"
        return 1
    fi

    # Keep only last N Cowboy snapshots (ONLY delete cowboy-rollback-* snapshots!)
    mapfile -t COWBOY_SNAPS < <(find "$SNAP_DIR" -maxdepth 1 -type d -name "cowboy-rollback-*" | sort -r)
    SNAP_COUNT=${#COWBOY_SNAPS[@]}
    
    if [ "$SNAP_COUNT" -gt "$KEEP_SNAPSHOTS" ]; then
        # Delete oldest Cowboy snapshots (keep newest KEEP_SNAPSHOTS)
        for (( i=KEEP_SNAPSHOTS; i<SNAP_COUNT; i++ )); do
            OLDEST="${COWBOY_SNAPS[$i]}"
            if sudo btrfs subvolume delete "$OLDEST"; then
                echo "$(date '+%F %T') | SNAPSHOT | BTRFS | Deleted $(basename "$OLDEST")" >> "$LOG_FILE"
            else
                warn "Failed to delete snapshot: $OLDEST"
            fi
        done
    fi

    echo
    echo -e "${CYAN}Btrfs snapshot created at $SNAP_PATH${RESET}"
    echo -e "${CYAN}Note: In case of issues, select this snapshot from your bootloader (Grub/Limine) to rollback.${RESET}"
    echo
}

log_summary() {
    # Default values if variables are unset
    SNAPSHOT_STATUS="${SNAPSHOT_STATUS:-NO}"
    SNAPSHOT_INFO="${SNAPSHOT_INFO:-None}"

    echo "$(date '+%F %T') | Time: ${MINUTES}m ${SECONDS}s | Packages: $PACKAGES_UPDATED | AUR: $AUR_UPDATED | Flatpaks: $FLATPAKS_UPDATED | Orphans: $ORPHANS_REMOVED | Cache: $CACHE_CLEANED | Kernel: $([ "$KERNEL_UPDATED" = true ] && echo YES || echo NO) | GPU: $([ "$GPU_UPDATED" = true ] && echo YES || echo NO) | Snapshot: $SNAPSHOT_STATUS | Latest Snapshot: $SNAPSHOT_INFO" >> "$LOG_FILE"
}


report_pacnew_files() {
    PACNEW_COUNT=$(find /etc -name "*.pacnew" 2>/dev/null | wc -l)
    PACSAVE_COUNT=$(find /etc -name "*.pacsave" 2>/dev/null | wc -l)

    if [ "$PACNEW_COUNT" -eq 0 ] && [ "$PACSAVE_COUNT" -eq 0 ]; then
        return
    fi

    echo
    echo -e "${YELLOW}‚ö†Ô∏è  Config files need review${RESET}"
    echo "  .pacnew files:  $PACNEW_COUNT"
    echo "  .pacsave files: $PACSAVE_COUNT"
    echo
    echo "Nothing was overwritten."
    echo "Review later with:"
    echo "  sudo pacdiff"
    echo

    echo "$(date '+%F %T') | PACNEW | $PACNEW_COUNT pacnew | $PACSAVE_COUNT pacsave" >> "$LOG_FILE"
}

# Verify pacman database isn't corrupted
check_database_health() {
    echo "Checking pacman database integrity..."

    # pacman -Qk returns non-zero when missing files exist (normal)
    DB_OUTPUT=$(pacman -Qk 2>/dev/null || true)

    # Extract ONLY package summary lines with missing files
    BAD_PKGS=$(echo "$DB_OUTPUT" \
        | grep -E "missing file[s]?\)$" \
        | grep -v ": 0 missing" \
        || true)

    if [ -z "$BAD_PKGS" ]; then
        echo -e "${GREEN}‚úì Database is healthy${RESET}"
        echo "$(date '+%F %T') | DB CHECK | OK | 0 packages affected" >> "$LOG_FILE"
        return 0
    fi

    PKG_COUNT=$(echo "$BAD_PKGS" | wc -l)

    echo -e "${YELLOW}‚ö†Ô∏è  $PKG_COUNT package(s) with missing files detected${RESET}"
    echo
    echo "$BAD_PKGS"
    echo

    if [ "$PKG_COUNT" -le 3 ]; then
        echo -e "${DIM}This is very common on Arch and usually harmless.${RESET}"
        echo -e "${DIM}Optional fix:${RESET}"
        echo -e "${DIM}  sudo pacman -Syu --overwrite '*'${RESET}"
        SEVERITY="LOW"
        warn "some missing packages, continuing update."
    else
        echo -e "${RED}‚ö†Ô∏è  Multiple packages affected ‚Äî investigate.${RESET}"
        SEVERITY="HIGH"
    fi

    echo "$(date '+%F %T') | DB CHECK | $SEVERITY | $PKG_COUNT packages affected" >> "$LOG_FILE"
}

echo -e "${CYAN}
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                  ‚ïë
‚ïë       COWBOY-UPDATE SCRIPT       ‚ïë
‚ïë              ${VERSION}                ‚ïë
‚ïë                                  ‚ïë
‚ïë              sunny               ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${RESET}"
cat <<'EOF'
  (                                 _
   )                               /=>
  (  +____________________/\/\___ / /|
   .''._____________'._____      / /|/\
  : () :              :\ ----\|    \ )
   '..'______________.'0|----|      \
                    0_0/____/        \
                        |----    /----\
                       || -\\ --|      \
                       ||   || ||\      \
                        \\____// '|      \
                                .'/       |
                               .:/        |
                               :/_________|
EOF
read -p "Press Enter to begin..."

self_update
create_rollback_snapshot

# Track stats
PACKAGES_UPDATED=0
AUR_UPDATED=0
FLATPAKS_UPDATED=0
ORPHANS_REMOVED=0
CACHE_CLEANED="0 MB"
START_TIME=$(date +%s)

# Check Arch news
echo
echo -e "${BOLD}Checking recent Arch news...${RESET}"
curl -s https://archlinux.org/feeds/news/ | grep -oP '(?<=<title>).*?(?=</title>)' | head -n 5 | tail -n 4
echo ""
read -p "Press Enter to continue with updates..."
echo

# Track if kernel or GPU drivers were updated during this run
KERNEL_UPDATED=false
GPU_UPDATED=false

warn_large_update
check_disk_space
check_database_health

# Update official repos
echo
echo "======================================="
echo -e "${GREEN}Updating Official Repository...${RESET}"
echo "======================================="
# Capture pacman output to check if kernel was updated
PACMAN_LOG=$(mktemp)

# Run pacman (disable exit-on-error for this command)
set +e
script -q -c "pacman -Syu" "$PACMAN_LOG"
PACMAN_EXIT=$?
set -e

PACMAN_OUTPUT=$(cat "$PACMAN_LOG")
rm "$PACMAN_LOG"

# Count packages updated (handle case where grep finds nothing)
if echo "$PACMAN_OUTPUT" | grep -q "upgrading"; then
    PACKAGES_UPDATED=$(echo "$PACMAN_OUTPUT" | grep -c "upgrading")
else
    PACKAGES_UPDATED=0
fi

# Check for any kernel package update (CachyOS or standard Arch)
if echo "$PACMAN_OUTPUT" | grep -qE 'upgrading linux(-|$)'; then
    KERNEL_UPDATED=true
fi

# Check for GPU driver updates (NVIDIA, AMD, Intel)
if echo "$PACMAN_OUTPUT" | grep -qE 'upgrading (nvidia|mesa|xf86-video|vulkan-|amdgpu)'; then
    GPU_UPDATED=true
fi

if [ $PACMAN_EXIT -ne 0 ] || echo "$PACMAN_OUTPUT" | tail -5 | grep -qi "error\|failed"; then
        echo -e "${YELLOW}pacman failed!${RESET}"
        print_failure_art
        notify_user "Update Failed" "pacman failed" cowboy-icon
        fatal "pacman failed"
fi

echo
echo "======================================="
echo -e "${GREEN}Updating AUR Packages...${RESET}"
echo "======================================="
set +e
AUR_OUTPUT=$(sudo -u "$ORIGINAL_USER" paru -Sua 2>&1 | tee /dev/tty)
PARU_EXIT=$?
set -e

# Count AUR packages updated
if echo "$AUR_OUTPUT" | grep -q "upgrading"; then
    AUR_UPDATED=$(echo "$AUR_OUTPUT" | grep -c "upgrading")
else
    AUR_UPDATED=0
fi

if [ $PARU_EXIT -ne 0 ]; then
    echo -e "${YELLOW}paru failed!${RESET}"
    print_failure_art
    notify_user "Update Failed" "paru failed" cowboy-icon
    warn "paru failed, continuing update"
fi

echo
echo "======================================="
echo -e "${GREEN}Updating Flatpaks...${RESET}"
echo "======================================="

# Update system-level flatpaks (as root)
echo "Updating system flatpaks..."
set +e
FLATPAK_SYSTEM_OUTPUT=$(flatpak update --system -y 2>&1 | tee /dev/tty)
FLATPAK_SYSTEM_EXIT=$?
set -e
echo

# Update user-level flatpaks (as original user)
echo "Updating user flatpaks..."
set +e
FLATPAK_USER_OUTPUT=$(sudo -u "$ORIGINAL_USER" DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" flatpak update --user -y 2>&1 | tee /dev/tty)
FLATPAK_USER_EXIT=$?
set -e

# Count updates from both outputs
SYSTEM_COUNT=0
USER_COUNT=0
if echo "$FLATPAK_SYSTEM_OUTPUT" | grep -q "Installing\|Updating"; then
    SYSTEM_COUNT=$(echo "$FLATPAK_SYSTEM_OUTPUT" | grep -c "Installing\|Updating")
fi
if echo "$FLATPAK_USER_OUTPUT" | grep -q "Installing\|Updating"; then
    USER_COUNT=$(echo "$FLATPAK_USER_OUTPUT" | grep -c "Installing\|Updating")
fi
FLATPAKS_UPDATED=$((SYSTEM_COUNT + USER_COUNT))

# Check if either failed
if [ $FLATPAK_SYSTEM_EXIT -ne 0 ] || [ $FLATPAK_USER_EXIT -ne 0 ]; then
    echo -e "${YELLOW}flatpak update failed!${RESET}"
    print_failure_art
    notify_user "Update Failed" "flatpak failed" cowboy-icon
    warn "flatpak failed, continuing update"
fi

echo
echo "======================================="
echo -e "${YELLOW}Cleaning...${RESET}"
echo "======================================="
# Show disk space saved - var before
BEFORE=$(df / | tail -1 | awk '{print $4}')

# Check for orphaned packages
echo
echo "Checking for orphaned packages..."
echo
ORPHANS=$(pacman -Qtdq 2>/dev/null || true)
if [ -n "$ORPHANS" ]; then
    ORPHANS_REMOVED=$(echo "$ORPHANS" | wc -l)
    ORPHANS_REMOVED=${ORPHANS_REMOVED//[^0-9]/}  # Keep only digits
    echo "Found orphaned packages:"
    echo "$ORPHANS"
    read -p "Remove them? (y/n): " choice
    if [[ $choice == "y" || $choice == "Y" ]]; then
        set +e
        pacman -Rns $ORPHANS --noconfirm
        set -e
    else
        ORPHANS_REMOVED=0
    fi
else
    echo "No orphaned packages found."
    echo
    ORPHANS_REMOVED=0
fi

# Clean package cache (keep last 2 versions)
echo "Cleaning package cache..."
echo
if command -v paccache &> /dev/null; then

    CACHE_BEFORE=$(du -sm /var/cache/pacman/pkg/ | awk '{print $1}')
    
    paccache -rk2 > /dev/null 2>&1
    paccache -ruk0 > /dev/null 2>&1
    
    CACHE_AFTER=$(du -sm /var/cache/pacman/pkg/ | awk '{print $1}')
    CACHE_CLEANED="$((CACHE_BEFORE - CACHE_AFTER)) MB"
else
    echo "paccache not found (install pacman-contrib)"
    CACHE_CLEANED="0 MB"
fi

# Clean Flatpak cache
if command -v flatpak &> /dev/null; then
    echo "Cleaning Flatpak cache..."
    echo
    # Clean system flatpaks
    flatpak uninstall --system --unused -y > /dev/null 2>&1
    # Clean user flatpaks
    sudo -u "$ORIGINAL_USER" DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$ORIGINAL_UID/bus" flatpak uninstall --user --unused -y > /dev/null 2>&1
fi

report_pacnew_files

# List services using old libraries
if command -v needrestart &> /dev/null; then
    echo "Checking for services needing restart..."
    needrestart -l
fi

# ... do updates and cleaning results...
AFTER=$(df / | tail -1 | awk '{print $4}')
SAVED=$((AFTER - BEFORE))  # in KB (usually df -k, but yours seems blocks?)
SAVED_MB=$((SAVED / 1024))

if [ "$SAVED_MB" -ge 1024 ]; then
    # Convert to GB with one decimal
    SAVED_GB=$(awk "BEGIN {printf \"%.1f\", $SAVED_MB/1024}")
    echo "Freed up: ${SAVED_GB} GB"
else
    echo "Freed up: ${SAVED_MB} MB"
fi


# Check if reboot needed
if [ "$KERNEL_UPDATED" = true ] || [ "$GPU_UPDATED" = true ]; then
    echo
    echo "‚ö†Ô∏è  ========================================== ‚ö†Ô∏è"
    echo "‚ö†Ô∏è           REBOOT RECOMMENDED              ‚ö†Ô∏è"
    echo "‚ö†Ô∏è  ========================================== ‚ö†Ô∏è"
    
    if [ "$KERNEL_UPDATED" = true ] && [ "$GPU_UPDATED" = true ]; then
        echo "   Kernel AND GPU drivers were updated!"
        notify_user "Reboot Recommended" "Kernel and GPU drivers updated" dialog-warning
    elif [ "$KERNEL_UPDATED" = true ]; then
        echo "   Kernel was updated!"
        notify_user "Reboot Recommended" "Kernel was updated" dialog-warning
    else
        echo "   GPU drivers were updated!"
        notify_user "Reboot Recommended" "GPU drivers updated" dialog-warning
    fi
    
    echo "‚ö†Ô∏è  ========================================== ‚ö†Ô∏è"
    echo
fi

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))
MINUTES=$((DURATION / 60))
SECONDS=$((DURATION % 60))

echo "+------------------------------------+"
echo -e "|${GREEN} SUCCESS! YOU CARRIED THAT WEIGHT!${RESET}  |"
echo "+------------------------------------+"
    echo -e "${BOLD}‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚†ã‚†ô‚†â‚†ã‚†õ‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†ø‚†ø‚†ø‚¢ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£•‚£¥‚£∂‚£ø‚£ø‚£ø‚£ø‚£∑‚£¶‚°à‚†ô‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†õ‚£Å‚£§‚£§‚£∂‚£∂‚£§‚£§‚£à‚£ª‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚°ø‚†ø‚†õ‚†õ‚†ª‚†ø‚£ø‚£ø‚£ø‚£ø‚£ß‚£à‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†è‚£°‚£æ‚£ø‚£ø‚£ø‚£ø‚°ø‚†ø‚¢ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°è‚†Ä‚°Ä‚†Ç‚†Ñ‚°Å‚†ê‚¢ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†â‚†Ä‚°Ä‚†Ñ‚††‚†Ä‚†ô‚£ø‚£ø
‚£ø‚°ø‚¢ø‚£∑‚£¶‚£§‚£•‚£¥‚£§‚£µ‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£§‚£Å‚£Ä‚£Ç‚£Å‚£¨‚£¥‚°ø‚¢ø
‚£ø‚†Ä‚£¶‚£â‚†õ‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†ã‚£°‚£¥‚†à
‚£ß‚†Ä‚£ø‚£ø‚¢∞‚£¶‚£¨‚£â‚†õ‚†ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†ü‚†ã‚£â‚£§‚£∂‚¢ê‚£ø‚£ø‚†Ä
‚£ø‚†Ä‚£ø‚°ø‚¢∏‚£ø‚£ø‚£ø‚£ø‚†Ä‚£§‚£§‚£ç‚£â‚£ô‚†ô‚†õ‚†õ‚†õ‚†õ‚†õ‚†â‚£â‚£â‚£•‚£§‚£§‚†Ä‚£ø‚£ø‚£ø‚£ø‚¢∏‚£ø‚°ü‚¢†
‚£ø‚°Ñ‚¢ª‚°á‚¢∏‚£ø‚£ø‚£ø‚£ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚°á‚††‚£ø‚£ø‚£ø‚°ø‚¢∏‚£ø‚†á‚£º
‚£ø‚£∑‚°à‚†á‚¢∏‚£ø‚£ø‚£ø‚£ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚°á‚¢à‚£ø‚£ø‚£ø‚£ø‚°á‚¢∏‚£ø‚£ø‚£ø‚°á‚¢∏‚°ü‚¢†‚£ø
‚£ø‚£ø‚£∑‚°Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚°á‚¢∏‚£ø‚£ø‚£ø‚£ø‚°á‚¢∏‚£ø‚£ø‚£ø‚°á‚†ò‚¢†‚£ø‚£ø
‚£ø‚£ø‚£ø‚£∑‚£å‚†ª‚£ø‚£ø‚£ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚£ø‚£ø‚£ø‚£ø‚°á‚¢∏‚£ø‚£ø‚£ø‚£ø‚°á‚¢∏‚£ø‚£ø‚°ø‚†É‚£∞‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚°à‚†ª‚°è‚††‚£ø‚£ø‚£ø‚£ø‚°è‚†ê‚£ø‚£ø‚£ø‚£ø‚°á‚¢∏‚£ø‚£ø‚£ø‚£ø‚°á‚¢∏‚°ø‚†õ‚£°‚£æ‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Ñ‚°ê‚†ª‚¢ø‚£ø‚£ø‚°á‚¢®‚£ø‚£ø‚£ø‚£ø‚°á‚¢∏‚£ø‚£ø‚£ø‚°ø‚†É‚£à‚£§‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¶‚£¨‚£â‚£É‚†ò‚†õ‚†õ‚†õ‚†õ‚†É‚†ò‚£õ‚£â‚£•‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø${RESET}"

# --- Snapshot Summary ---
echo "+------------------------------------+"
echo -e "|${GREEN}          BACKUP SUMMARY${RESET}            |"
echo "+------------------------------------+"

if [ -d "$SNAP_DIR" ]; then
    # Get most recent snapshot
    LATEST_SNAP=$(ls -1t "$SNAP_DIR" 2>/dev/null | head -1)
    if [ -z "$LATEST_SNAP" ]; then
        echo "No Cowboy rollback snapshots found."
        SNAPSHOT_STATUS="NO"
        SNAPSHOT_INFO="NONE"
    else
        SNAP_PATH="$SNAP_DIR/$LATEST_SNAP"
        SNAP_TS=$(stat -c %Y "$SNAP_PATH" 2>/dev/null || echo 0)
        AGE_DAYS=$(( ( $(date +%s) - SNAP_TS ) / 86400 ))
        echo "$LATEST_SNAP (age: $AGE_DAYS day(s)) at $SNAP_PATH"
        SNAPSHOT_STATUS="YES"
        SNAPSHOT_INFO="$LATEST_SNAP (age: $AGE_DAYS day(s)) at $SNAP_PATH"
    fi
else
    echo "Snapshot directory $SNAP_DIR not found."
    SNAPSHOT_STATUS="NO"
    SNAPSHOT_INFO="NONE"
fi

echo -e "${MAGENTA}^^IN CASE OF EMERGENCY: USE YOUR BOOTLOADER TO ROLLBACK LAST SNAPSHOT^^${RESET}"

# --- Update Summary ---
log_summary

echo -e "${CYAN}+------------------------------------+"
echo "|          UPDATE SUMMARY            |"
echo -e "+------------------------------------+${RESET}"
printf "| %-34s |\n" "Packages updated: $PACKAGES_UPDATED"
printf "| %-34s |\n" "AUR packages updated: $AUR_UPDATED"
printf "| %-34s |\n" "Flatpaks updated: $FLATPAKS_UPDATED"
printf "| %-34s |\n" "Orphans removed: $ORPHANS_REMOVED"
printf "| %-34s |\n" "Cache cleaned: $CACHE_CLEANED"
printf "| %-34s |\n" "Kernel updated: $([ "$KERNEL_UPDATED" = true ] && echo "YES" || echo "NO")"
printf "| %-34s |\n" "GPU drivers updated: $([ "$GPU_UPDATED" = true ] && echo "YES" || echo "NO")"
printf "| %-34s |\n" "Rollback snapshot: $SNAPSHOT_STATUS"
printf "| %-34s |\n" "Time taken: ${MINUTES}m ${SECONDS}s"
echo "+------------------------------------+"
echo -e "${CYAN}Log of this update has been saved to:${RESET}"
echo -e "${BOLD}$LOG_FILE${RESET}"
echo

reboot_prompt
notify_user "System Updated" "Yeehaw"

read -p "Press Enter to close, space cowboy..."
